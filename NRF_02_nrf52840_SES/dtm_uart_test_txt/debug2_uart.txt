



===========================uart init===================================

flow：

     uart_init  --  APP_UART_FIFO_INIT  --   app_uart_init  --  nrf_drv_uart_init  --  nrfx_uarte_init  --  apply_config

数据流：  (rx_buf + tx_buf)  --> buffers  -->  (m_rx_fifo  + m_tx_fifo )  
数据流2： params  -->  config
数据流3： uart_error_handle  -->  m_handlers[0]
数据流4： 0   -->  m_contexts[0]
数据流51： uart_error_handle + config + 常量 -->  m_cb[0]  
数据流52： rx_buffer -->  m_cb
数据流6： rx_buffer  -->  RXD.PTR， 1  -->  RXD.MAXCNT 
----------------------------------------------------

int main( ) 
    
    uart_init(); 

-------------------------------------------------------


void uart_init(void)
 
    uint32_t err_code;
    const app_uart_comm_params_t comm_params =
      {
          RX_PIN_NUMBER,      //P1.10
          TX_PIN_NUMBER,      //P1.15
          RTS_PIN_NUMBER,    //P0.5
          CTS_PIN_NUMBER,    //0.7
          APP_UART_FLOW_CONTROL_DISABLED,
          false,
          DTM_BITRATE       //19200
      };

    APP_UART_FIFO_INIT(&comm_params,
                       UART_RX_BUF_SIZE,                   // 256
                       UART_TX_BUF_SIZE,                   // 256
                       uart_error_handle,
                       APP_IRQ_PRIORITY_LOWEST,      // 7
                       err_code);

-----------------

参数：   params, 256， 256， uart_error_handle,  7，  err_code
数据流：  rx_buf + tx_buf  --> buffers
#define APP_UART_FIFO_INIT(P_COMM_PARAMS,   RX_BUF_SIZE,   TX_BUF_SIZE,   EVT_HANDLER, IRQ_PRIO,   ERR_CODE)  
    do                                                                                             
    {                                                                                              
        app_uart_buffers_t buffers;       //全局变量                                                                    
        static uint8_t     rx_buf[256];      //全局变量                                                
        static uint8_t     tx_buf[256];                                                     
                                                                                                    
        buffers.rx_buf      = rx_buf;                                                               
        buffers.rx_buf_size = sizeof (rx_buf);                                                      
        buffers.tx_buf      = tx_buf;                                                              
        buffers.tx_buf_size = sizeof (tx_buf);                                                     
        ERR_CODE = app_uart_init(P_COMM_PARAMS, &buffers, EVT_HANDLER, 7);                  
    } while (0)
 
-----------------

参数：   params,  buffers， uart_error_handle,  7 
数据流： buffers  -->  m_rx_fifo  + m_tx_fifo
数据流2：params  -->  config
app_uart_init(  * p_comm_params,  *p_buffers,  event_handler,    irq_priority)
 
    uint32_t err_code;

    m_event_handler = event_handler;
 
    //app_fifo_init(&m_rx_fifo, p_buffers->rx_buf, p_buffers->rx_buf_size); 
        m_rx_fifo->p_buf         =  p_buffers->rx_buf;
        m_rx_fifo->buf_size_mask = p_buffers->rx_buf_size - 1;
        m_rx_fifo->read_pos      = 0;
        m_rx_fifo->write_pos     = 0;

    //app_fifo_init(&m_tx_fifo, p_buffers->tx_buf, p_buffers->tx_buf_size);
        m_tx_fifo->p_buf         =  p_buffers->tx_buf;
        m_tx_fifo->buf_size_mask = p_buffers->tx_buf_size - 1;
        m_tx_fifo->read_pos      = 0;
        m_tx_fifo->write_pos     = 0;
 
    nrf_drv_uart_config_t   config = NRF_DRV_UART_DEFAULT_CONFIG;

    config.baudrate =p_comm_params->baud_rate;
    config.hwfc = (p_comm_params->flow_control == 0) ?  NRF_UART_HWFC_DISABLED : NRF_UART_HWFC_ENABLED;   // 无硬件流控制
    config.interrupt_priority = irq_priority;   // 7
    config.parity = p_comm_params->use_parity ? NRF_UART_PARITY_INCLUDED : NRF_UART_PARITY_EXCLUDED;          // 无奇偶
    config.pselcts = p_comm_params->cts_pin_no;
    config.pselrts = p_comm_params->rts_pin_no;
    config.pselrxd = p_comm_params->rx_pin_no;      // P1.15
    config.pseltxd = p_comm_params->tx_pin_no;      // P1.10

    nrf_drv_uart_init(&app_uart_inst, &config, uart_event_handler); 
 
    m_rx_ovf = false;

    //nrf_drv_uart_rx(&app_uart_inst, rx_buffer,1); 
         nrfx_uarte_rx(&app_uart_inst->uarte, rx_buffer,1); 


-----------------

// 参数： &app_uart_inst 
             .inst_idx =0,          
             .uarte.p_reg         =  NRF_UARTE0
             .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   // 0
             .uart.p_reg           =  NRF_UART0     
             .uart.drv_inst_idx    =  NRFX_UART0_INST_IDX    // 0

参数： app_uart_inst->uarte,  rx_buffer,  1
数据流： rx_buffer -->  m_cb
数据流2： rx_buffer  -->  RXD.PTR， 1  -->  RXD.MAXCNT 
nrfx_uarte_rx(  * p_instance, * p_data,  length)   
 
    uarte_control_block_t * p_cb = &m_cb[0];

    //if (!nrfx_is_in_ram(p_data))                                     //no, 跳过
        if ( rx_buffer & 0xE0000000 )  != 0x20000000)    
           return err_code; 

    bool second_buffer = false;

    if (p_cb->handler)           //  yes， uart_error_handle
        nrf_uarte_int_disable( NRF_UARTE0 , NRF_UARTE_INT_ERROR_MASK |  NRF_UARTE_INT_ENDRX_MASK);      //或关闭uartrx中断
    
    if ( p_cb->rx_buffer_length != 0 )         //no, 跳过
     
        if ( p_cb->rx_secondary_buffer_length != 0 )            
            if (p_cb->handler)        //  yes， uart_error_handle             
                nrf_uarte_int_enable(p_instance->p_reg, NRF_UARTE_INT_ERROR_MASK |  NRF_UARTE_INT_ENDRX_MASK);
            return err_code;         
        second_buffer = true;
     

    if (!second_buffer)     //yes 

        p_cb->rx_buffer_length = length;
        p_cb->p_rx_buffer      = p_data;
        p_cb->rx_secondary_buffer_length = 0;
 
    else   //no
        p_cb->p_rx_secondary_buffer = p_data;
        p_cb->rx_secondary_buffer_length = length;

    nrf_uarte_event_clear(p_instance->p_reg, NRF_UARTE_EVENT_ENDRX);   //或清除中断标志
    nrf_uarte_event_clear(p_instance->p_reg, NRF_UARTE_EVENT_RXTO);     //或清除中断标志

    //nrf_uarte_rx_buffer_set(NRF_UARTE0,  rx_buffer,  1 );
        NRF_UARTE0->RXD.PTR    = rx_buffer;
        NRF_UARTE0->RXD.MAXCNT =1;


    if (!second_buffer)    //yes
   
        //nrf_uarte_task_trigger(p_instance->p_reg, NRF_UARTE_TASK_STARTRX);
           TASK_STARTRX = 1;    //开启uarte 接收

    else     //no
        nrf_uarte_shorts_enable(p_instance->p_reg, NRF_UARTE_SHORT_ENDRX_STARTRX);
            SHORTS |= (1<<5);   //使能shortcut ， startrx 和 endrx之间的shortcut      //待理解

//-------------------------------待续----------------------------------------------------


    if (m_cb[0].handler == NULL)   //no       
            。。。 
  
    else 

        //nrf_uarte_int_enable(p_instance->p_reg, NRF_UARTE_INT_ERROR_MASK |   NRF_UARTE_INT_ENDRX_MASK);
              INTENSET = ERROR | ENDRX；
 



 ---------

// 参数： &app_uart_inst,  &config,  uart_error_handle
             .inst_idx =0,          
             .uarte.p_reg         =  NRF_UARTE0
             .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   // 0
             .uart.p_reg           =  NRF_UART0     
             .uart.drv_inst_idx    =  NRFX_UART0_INST_IDX    // 0

数据流：uart_error_handle  -->  m_handlers[0]
数据流：0   -->  m_contexts[0]
nrf_drv_uart_init(  *p_instance, *p_config,  event_handler)
 
    uint32_t  inst_idx = p_instance->inst_idx;       // 0

    m_handlers[0] = event_handler;                   // uart_event_handler
    m_contexts[0] = p_config->p_context;          // null
 
    nrf_drv_uart_use_easy_dma[0] = p_config->use_easy_dma;  // 1
 
    nrf_drv_uart_config_t    config = *p_config; 
    config.p_context = inst_idx;   // 0

    ret_code_t result = 0;

    //if (NRF_DRV_UART_USE_UARTE)
       if( nrf_drv_uart_use_easy_dma[0] )                 //1    //yes    (已打log验证) 
          nrfx_uarte_init(&p_instance->uarte,  &config,  uarte_evt_handler );
 

------------

// 参数： &app_uart_inst.uarte,  &config,  uart_error_handle
             .uarte.p_reg         =  NRF_UARTE0
             .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   // 0

数据流：uart_error_handle + config + 常量 -->  m_cb[0]      //给m_cb[0]赋值（大部分， 发送和接收缓冲尚未赋值）
nrfx_uarte_init( *p_instance,  *p_config,  event_handler)
 
    uarte_control_block_t * p_cb = &m_cb[0];       // p_instance->drv_inst_idx=0
 
    static nrfx_irq_handler_t  const irq_handlers[1] = { nrfx_uarte_0_irq_handler };   //NRFX_UARTE_ENABLED_COUNT=1
 
     。。。（参考1--定义prs_box_t 变量记录已初始化标志，跳过）


    apply_config(p_instance, p_config);     //配置串口引脚和波特率 

    p_cb->handler   = event_handler;              //uart_error_handle
    p_cb->p_context = p_config->p_context;   //null

    if (p_cb->handler)
        interrupts_enable(p_instance, p_config->interrupt_priority);  //清中断标志，开启中断和优先级，使能中断
 
    nrf_uarte_enable(p_instance->p_reg);   //使能串口

    p_cb->rx_buffer_length           = 0;
    p_cb->rx_secondary_buffer_length = 0;
    p_cb->tx_buffer_length           = 0;
    p_cb->state                      = NRFX_DRV_STATE_INITIALIZED;
 
 

-----------------------------------

// 功能： 配置串口引脚和波特率
// 参数： &app_uart_inst.uarte,  &config 
             .uarte.p_reg         =  NRF_UARTE0
             .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   // 0
             config.pselrxd =   P1.15
             config.pseltxd =  P1.10
             config.baudrate  = 119200

apply_config( * p_instance, * p_config) 
 
        nrf_gpio_pin_set(p_config->pseltxd);             //tx  P1.10， output  1
        nrf_gpio_cfg_output(p_config->pseltxd); 
 
        nrf_gpio_cfg_input(p_config->pselrxd, NRF_GPIO_PIN_NOPULL);                   //rx   P1.15 ， input  nopull

        nrf_uart_baudrate_set(p_instance->p_reg, p_config->baudrate);                       //设置波特率  19200

        nrf_uart_configure(p_instance->p_reg, p_config->parity, p_config->hwfc);         //设置，无奇偶校验，无硬件流控制

        nrf_uart_txrx_pins_set(p_instance->p_reg, p_config->pseltxd, p_config->pselrxd);   //设置uart的tx，rx引脚

    

-------


 app_fifo_init(  * p_fifo,   * p_buf,  buf_size) 
 
    if (!IS_POWER_OF_TWO(buf_size))    //判断是否为2的n次方，如果不是则返回错误
        return err; 

    p_fifo->p_buf         = p_buf;
    p_fifo->buf_size_mask = buf_size - 1;
    p_fifo->read_pos      = 0;
    p_fifo->write_pos     = 0;
 




===========================uart tx===================================


flow：

       app_uart_put  --  app_fifo_put --  fifo_put   --  ？

数据流： 0x80 --  (m_tx_fifo ) --  tx_buf  --  tx_buffer

--------------------------

main 
       app_uart_put(0x80);

------------------------------------

隐含参数：m_tx_fifo
        m_tx_fifo->p_buf         =   tx_buf[256];
        m_tx_fifo->buf_size_mask = 256-1;
        m_tx_fifo->read_pos      = 0;
        m_tx_fifo->write_pos     = 0;

隐含参数：app_uart_inst
       .inst_idx =APP_UART_DRIVER_INSTANCE，//0          
       .uarte.p_reg         =  NRF_UARTE0
       .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   //0

参数： 0x80
app_uart_put(  byte )
 
    uint32_t err_code;

    //app_fifo_put(&m_tx_fifo, byte);
    //   fifo_put(m_tx_fifo, byte);

         //p_fifo->p_buf[p_fifo->write_pos] = byte;     // 0x80 --  (m_tx_fifo ) --  tx_buf
             tx_buf[*->write_pos] = byte;      
          *->write_pos++;
 
    //if (!nrf_drv_uart_tx_in_progress(&app_uart_inst))
    //    if(nrfx_uarte_tx_in_progress(&p_instance->uarte);)
             if( m_cb[0].tx_buffer_length != 0);                            //？
 
               app_fifo_get(&m_tx_fifo, tx_buffer);                   // (m_tx_fifo ) --  tx_buf  --  tx_buffer
                   *p_byte = p_fifo->p_buf[ *->read_pos ];
                    p_fifo->read_pos++;

               //nrf_drv_uart_tx(&app_uart_inst, tx_buffer, 1);
               //   nrfx_uarte_tx(app_uart_inst->uarte,  tx_buffer,  1);
                        nrfx_uarte_tx_with_hold(app_uart_inst->uarte,  tx_buffer,  1, false);

--------------------------

隐含参数：app_uart_inst
       .inst_idx =APP_UART_DRIVER_INSTANCE，//0          
       .uarte.p_reg         =  NRF_UARTE0
       .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   //0

参数：  app_uart_inst->uarte,  tx_buffer,  1,  false
nrfx_uarte_tx_with_hold(  * p_instance, *p_data,  length,  hold_xfer)
{
    uarte_control_block_t * p_cb = &m_cb[0];

    // EasyDMA requires that transfer buffers are placed in DataRAM,
    // signal error if the are not.
    if (!nrfx_is_in_ram(p_data))
    {
        err_code = NRFX_ERROR_INVALID_ADDR;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }

    if (nrfx_uarte_tx_in_progress(p_instance))
    {
        err_code = NRFX_ERROR_BUSY;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    p_cb->tx_buffer_length = length;
    p_cb->p_tx_buffer      = p_data;

    NRFX_LOG_INFO("Transfer tx_len: %d.", p_cb->tx_buffer_length);
    NRFX_LOG_DEBUG("Tx data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_cb->p_tx_buffer,
                           p_cb->tx_buffer_length * sizeof(p_cb->p_tx_buffer[0]));

    err_code = NRFX_SUCCESS;

    nrf_uarte_event_clear(p_instance->p_reg, NRF_UARTE_EVENT_ENDTX);
    nrf_uarte_event_clear(p_instance->p_reg, NRF_UARTE_EVENT_TXSTOPPED);
    nrf_uarte_tx_buffer_set(p_instance->p_reg, p_cb->p_tx_buffer, p_cb->tx_buffer_length);
    if(!hold_xfer) nrf_uarte_task_trigger(p_instance->p_reg, NRF_UARTE_TASK_STARTTX);

    if (p_cb->handler == NULL)
    {
        bool endtx;
        bool txstopped;
        do
        {
            endtx     = nrf_uarte_event_check(p_instance->p_reg, NRF_UARTE_EVENT_ENDTX);
            txstopped = nrf_uarte_event_check(p_instance->p_reg, NRF_UARTE_EVENT_TXSTOPPED);
        }
        while ((!endtx) && (!txstopped));

        if (txstopped)
        {
            err_code = NRFX_ERROR_FORBIDDEN;
        }
        else
        {
            // Transmitter has to be stopped by triggering the STOPTX task to achieve
            // the lowest possible level of the UARTE power consumption.
            nrf_uarte_task_trigger(p_instance->p_reg, NRF_UARTE_TASK_STOPTX);

            while (!nrf_uarte_event_check(p_instance->p_reg, NRF_UARTE_EVENT_TXSTOPPED))
            {}
        }
        p_cb->tx_buffer_length = 0;
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}

--------

参数：  m_tx_fifo ， 0x80
        m_tx_fifo->p_buf         =  tx_buf[256];
        m_tx_fifo->buf_size_mask = 255;
        m_tx_fifo->read_pos      = 0;
        m_tx_fifo->write_pos     = 0;

数据流： 0x80  --   (m_tx_fifo ) -- tx_buf  
app_fifo_put(  * p_fifo,   byte)
 
    //if (FIFO_LENGTH() <= p_fifo->buf_size_mask)  
   //    if ( fifo_length(p_fifo) <= 255)  
            if( (p_fifo->write_pos - p_fifo->read_pos)  <= 255 )  //如果fifo长度小于255(就是卡车没装满)，则运行下面

                //fifo_put(p_fifo, byte);
                    tx_buf[*->write_pos] = byte;     //0x80
                    *->write_pos++;
-------

参数：m_tx_fifo, tx_buffer
        m_tx_fifo->p_buf         =  tx_buf[256];
        m_tx_fifo->buf_size_mask = 255;
        m_tx_fifo->read_pos      = 0;
        m_tx_fifo->write_pos     = 0;

数据流： (m_tx_fifo ) --   tx_buf  -->  tx_buffer
app_fifo_get( * p_fifo,  * p_byte)

    //if (FIFO_LENGTH() != 0) 
         if( (p_fifo->write_pos - p_fifo->read_pos)  >0 )     //如果fifo长度大于1(就是卡车里有数据)，则运行下面

        //fifo_get(p_fifo, p_byte);
             *p_byte = p_fifo->p_buf[ *->read_pos ];
              p_fifo->read_pos++;

        return NRF_SUCCESS;

    return NRF_ERROR_NOT_FOUND;
 

   
--------
  
 

   
 




===========================uart rx===================================



参数：   params,  buffers， uart_error_handle,  7 
数据流： buffers  -->  m_rx_fifo  + m_tx_fifo
数据流2：params  -->  config
app_uart_init(  * p_comm_params,  *p_buffers,  event_handler,    irq_priority)
 
    uint32_t err_code;

    m_event_handler = event_handler;
 
    //app_fifo_init(&m_rx_fifo, p_buffers->rx_buf, p_buffers->rx_buf_size); 
        m_rx_fifo->p_buf         =  p_buffers->rx_buf;
        m_rx_fifo->buf_size_mask = p_buffers->rx_buf_size - 1;
        m_rx_fifo->read_pos      = 0;
        m_rx_fifo->write_pos     = 0;

    //app_fifo_init(&m_tx_fifo, p_buffers->tx_buf, p_buffers->tx_buf_size);
        m_tx_fifo->p_buf         =  p_buffers->tx_buf;
        m_tx_fifo->buf_size_mask = p_buffers->tx_buf_size - 1;
        m_tx_fifo->read_pos      = 0;
        m_tx_fifo->write_pos     = 0;
 
    nrf_drv_uart_config_t   config = NRF_DRV_UART_DEFAULT_CONFIG;

    config.baudrate =p_comm_params->baud_rate;
    config.hwfc = (p_comm_params->flow_control == 0) ?  NRF_UART_HWFC_DISABLED : NRF_UART_HWFC_ENABLED;   // 无硬件流控制
    config.interrupt_priority = irq_priority;   // 7
    config.parity = p_comm_params->use_parity ? NRF_UART_PARITY_INCLUDED : NRF_UART_PARITY_EXCLUDED;          // 无奇偶
    config.pselcts = p_comm_params->cts_pin_no;
    config.pselrts = p_comm_params->rts_pin_no;
    config.pselrxd = p_comm_params->rx_pin_no;      // P1.15
    config.pseltxd = p_comm_params->tx_pin_no;      // P1.10

    nrf_drv_uart_init(&app_uart_inst, &config, uart_event_handler); 
 
    m_rx_ovf = false;

    nrf_drv_uart_rx(&app_uart_inst, rx_buffer,1); 
 










===============================跳过的参考====keep=============================


---------------------------------------------参考1---------------------------------------------------------------

    //if ( nrfx_prs_acquire( p_instance->p_reg,  irq_handlers[0] ) != NRFX_SUCCESS )          //no,跳过
    //    if ( nrfx_prs_acquire( NRF_UARTE0,  nrfx_uarte_0_irq_handler ) != NRFX_SUCCESS )  
              prs_box_t * p_box；
                  .handler = NULL 
                 .acquired = false 
              if (p_box->acquired)   //no，跳过
                   return =1；   //err
              p_box->handler  =uart_error_handle;
              p_box->acquired = true;
              return =0；    //ok

              if(return 1）   //err

                  err_code = NRFX_ERROR_BUSY;
                  。。。
 
------

参数：  NRF_UARTE0
static prs_box_t * prs_box_get(  * p_base_addr)
 
    //#define IS_PRS_BOX(n, p_base_addr)  ((p_base_addr) == NRFX_PRS_BOX_##n##_ADDR)
    #define IS_PRS_BOX(n, NRF_UARTE0)  (  NRF_UARTE0  == NRFX_PRS_BOX_##n##_ADDR)

    //if (IS_PRS_BOX(4, p_base_addr)) 
    if ( NRF_UARTE0  == NRFX_PRS_BOX_4_ADDR )      //yes

         //return &m_prs_box_4;  
              return m_prs_box_4 ； 
                    .handler = NULL 
                    .acquired = false 

    else 
        return NULL;

-----------------

// 参数： NRF_UARTE0,  nrfx_uarte_0_irq_handler  
nrfx_prs_acquire( * p_base_addr,  irq_handler) 

    //prs_box_t * p_box = prs_box_get(p_base_addr);
         p_box =  m_prs_box_4； 
             .handler = NULL 
             .acquired = false 

    if (p_box != NULL)
 
        bool busy = false;

        NRFX_CRITICAL_SECTION_ENTER();

        //if (p_box->acquired)
        //    busy = true;
        //else

            p_box->handler  = irq_handler;
            p_box->acquired = true;

        NRFX_CRITICAL_SECTION_EXIT();

        if (busy)    
            ret_code = NRFX_ERROR_BUSY;
            LOG_FUNCTION_EXIT(WARNING, ret_code);
            return ret_code;
        
    ret_code = NRFX_SUCCESS;
    LOG_FUNCTION_EXIT(INFO, ret_code);
    return ret_code;

---------

#define NRFX_PRS_BOX_4_ADDR     NRF_UARTE0     //nrfx_prs.h

typedef struct {
    nrfx_irq_handler_t     handler;
    bool                       acquired;
} prs_box_t;


#define PRS_BOX_DEFINE(n)      //n=4
                                                
    //static prs_box_t  m_prs_box_##n =  { .handler = NULL, .acquired = false };  
         static prs_box_t  m_prs_box_4 =  { .handler = NULL, .acquired = false };  

    void nrfx_prs_box_4_irq_handler(void)                               
    {                                                                       
         NRFX_ASSERT(m_prs_box_4.handler);                                   
         m_prs_box_4.handler();                                            
    }

---

m_prs_box_4

---------------------------------------------参考1---------end-----------------------------------------------------






