



===========================uart init===================================

int main( )
 
    
    uart_init(); 

-------------------------------------------------------


void uart_init(void)
 
    uint32_t err_code;
    const app_uart_comm_params_t comm_params =
      {
          RX_PIN_NUMBER,      //P1.10
          TX_PIN_NUMBER,      //P1.15
          RTS_PIN_NUMBER,    //P0.5
          CTS_PIN_NUMBER,    //0.7
          APP_UART_FLOW_CONTROL_DISABLED,
          false,
          DTM_BITRATE       //19200
      };

    APP_UART_FIFO_INIT(&comm_params,
                       UART_RX_BUF_SIZE,                   // 256
                       UART_TX_BUF_SIZE,                   // 256
                       uart_error_handle,
                       APP_IRQ_PRIORITY_LOWEST,      // 7
                       err_code);


-----------------

参数：   params, 256， 256， uart_error_handle,  7，  err_code
#define APP_UART_FIFO_INIT(P_COMM_PARAMS,   RX_BUF_SIZE,   TX_BUF_SIZE,   EVT_HANDLER, IRQ_PRIO,   ERR_CODE)  
    do                                                                                             
    {                                                                                              
        app_uart_buffers_t buffers;                                                                
        static uint8_t     rx_buf[256];                                                     
        static uint8_t     tx_buf[256];                                                     
                                                                                                    
        buffers.rx_buf      = rx_buf;                                                               
        buffers.rx_buf_size = sizeof (rx_buf);                                                      
        buffers.tx_buf      = tx_buf;                                                              
        buffers.tx_buf_size = sizeof (tx_buf);                                                     
        ERR_CODE = app_uart_init(P_COMM_PARAMS, &buffers, EVT_HANDLER, 7);                  
    } while (0)
 

-----------------

参数：   params, buffers， uart_error_handle,  7 
 app_uart_init(  * p_comm_params,  *p_buffers,  event_handler,    irq_priority)
 
    uint32_t err_code;

    m_event_handler = event_handler;
 
    //app_fifo_init(&m_rx_fifo, p_buffers->rx_buf, p_buffers->rx_buf_size); 
        m_rx_fifo->p_buf         =  p_buffers->rx_buf;
        m_rx_fifo->buf_size_mask = p_buffers->rx_buf_size - 1;
        m_rx_fifo->read_pos      = 0;
        m_rx_fifo->write_pos     = 0;

    //app_fifo_init(&m_tx_fifo, p_buffers->tx_buf, p_buffers->tx_buf_size);
        m_tx_fifo->p_buf         =  p_buffers->tx_buf;
        m_tx_fifo->buf_size_mask = p_buffers->tx_buf_size - 1;
        m_tx_fifo->read_pos      = 0;
        m_tx_fifo->write_pos     = 0;
 
    nrf_drv_uart_config_t   config = NRF_DRV_UART_DEFAULT_CONFIG;

    config.baudrate =p_comm_params->baud_rate;
    config.hwfc = (p_comm_params->flow_control == 0) ?  NRF_UART_HWFC_DISABLED : NRF_UART_HWFC_ENABLED;   // 无硬件流控制
    config.interrupt_priority = irq_priority;   // 7
    config.parity = p_comm_params->use_parity ? NRF_UART_PARITY_INCLUDED : NRF_UART_PARITY_EXCLUDED;          // 无奇偶
    config.pselcts = p_comm_params->cts_pin_no;
    config.pselrts = p_comm_params->rts_pin_no;
    config.pselrxd = p_comm_params->rx_pin_no;      // P1.15
    config.pseltxd = p_comm_params->tx_pin_no;      // P1.10

    nrf_drv_uart_init(&app_uart_inst, &config, uart_event_handler);
 
    m_rx_ovf = false;

    nrf_drv_uart_rx(&app_uart_inst, rx_buffer,1);
 

 ---------

// 参数： &app_uart_inst,  &config,  uart_error_handle
             .inst_idx =0,          
             .uarte.p_reg         =  NRF_UARTE0
             .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   // 0
             .uart.p_reg           =  NRF_UART0     
             .uart.drv_inst_idx    =  NRFX_UART0_INST_IDX    // 0

nrf_drv_uart_init(  *p_instance, *p_config,  event_handler)
 
    uint32_t  inst_idx = p_instance->inst_idx;                 // 0

    m_handlers[0] = event_handler;                   // uart_event_handler
    m_contexts[0] = p_config->p_context;          // null
 
    nrf_drv_uart_use_easy_dma[0] = p_config->use_easy_dma;  // 1
 
    nrf_drv_uart_config_t    config = *p_config; 
    config.p_context = inst_idx;   // 0

    ret_code_t result = 0;

    //if (NRF_DRV_UART_USE_UARTE)
       if( nrf_drv_uart_use_easy_dma[0] )                 //1    //yes    (已打log验证) 
          nrfx_uarte_init(&p_instance->uarte,  &config,  uarte_evt_handler );
 

------------

// 参数： &app_uart_inst.uarte,  &config,  uart_error_handle
             .uarte.p_reg         =  NRF_UARTE0
             .uarte.drv_inst_idx =  NRFX_UARTE0_INST_IDX   // 0

nrfx_uarte_init( *p_instance,  *p_config,  event_handler)
 
    uarte_control_block_t * p_cb = &m_cb[0];       // p_instance->drv_inst_idx=0
 
    static nrfx_irq_handler_t  const irq_handlers[1] = { nrfx_uarte_0_irq_handler };     //NRFX_UARTE_ENABLED_COUNT=1
 
    //if ( nrfx_prs_acquire( p_instance->p_reg,  irq_handlers[0] ) != NRFX_SUCCESS )
          if ( nrfx_prs_acquire( NRF_UARTE0,  nrfx_uarte_0_irq_handler ) != NRFX_SUCCESS )  

    {
        err_code = NRFX_ERROR_BUSY;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }


    apply_config(p_instance, p_config);

 

    p_cb->handler   = event_handler;
    p_cb->p_context = p_config->p_context;

    if (p_cb->handler)
    {
        interrupts_enable(p_instance, p_config->interrupt_priority);
    }

    nrf_uarte_enable(p_instance->p_reg);
    p_cb->rx_buffer_length           = 0;
    p_cb->rx_secondary_buffer_length = 0;
    p_cb->tx_buffer_length           = 0;
    p_cb->state                      = NRFX_DRV_STATE_INITIALIZED;
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
 

--------

// 参数： NRF_UARTE0,  nrfx_uarte_0_irq_handler  

nrfx_prs_acquire( * p_base_addr,  irq_handler) 

    //prs_box_t * p_box = prs_box_get(p_base_addr);
         p_box =  m_prs_box_4； 
             .handler = NULL 
             .acquired = false 

    if (p_box != NULL)
 
        bool busy = false;

        NRFX_CRITICAL_SECTION_ENTER();

        if (p_box->acquired)
            busy = true;

        else
            p_box->handler  = irq_handler;
            p_box->acquired = true;

        NRFX_CRITICAL_SECTION_EXIT();

        if (busy)    
            ret_code = NRFX_ERROR_BUSY;
            LOG_FUNCTION_EXIT(WARNING, ret_code);
            return ret_code;
        
    ret_code = NRFX_SUCCESS;
    LOG_FUNCTION_EXIT(INFO, ret_code);
    return ret_code;


 
------

参数：  NRF_UARTE0
static prs_box_t * prs_box_get(  * p_base_addr)
 
    //#define IS_PRS_BOX(n, p_base_addr)  ((p_base_addr) == NRFX_PRS_BOX_##n##_ADDR)
    #define IS_PRS_BOX(n, NRF_UARTE0)  (  NRF_UARTE0  == NRFX_PRS_BOX_##n##_ADDR)

    //if (IS_PRS_BOX(4, p_base_addr)) 
    if ( NRF_UARTE0  == NRFX_PRS_BOX_4_ADDR )      //yes

         //return &m_prs_box_4;  
              return m_prs_box_4 ； 
                    .handler = NULL 
                    .acquired = false 

    else 
        return NULL;
  
 


-------


 app_fifo_init(  * p_fifo,   * p_buf,  buf_size) 
 
    if (!IS_POWER_OF_TWO(buf_size))    //判断是否为2的n次方，如果不是则返回错误
        return err; 

    p_fifo->p_buf         = p_buf;
    p_fifo->buf_size_mask = buf_size - 1;
    p_fifo->read_pos      = 0;
    p_fifo->write_pos     = 0;
 






===========================uart tx===================================





===========================uart rx===================================

















