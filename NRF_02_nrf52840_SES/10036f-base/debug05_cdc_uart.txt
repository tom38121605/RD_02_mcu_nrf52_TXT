
注意1： 用sscom串口助手调试，需勾选 DTR
usb_serial_write((uint8_t*)"12345abcde",10);
nrf_delay_ms(100);

关于while中nrf_delay_ms延时不准的问题的原因：
   。是因为uart发送数据时，是累积到约128(OMMO_USB_SERIAL_MIN_PACKET_SIZE)个字节一起发送。  
   。二是等usb_serial_write_force=true再发送，可在定时器里面设置true，也可手动设置true


//usb_serial_send_ack(OMMO_ACK_SUCCESS);          //03 ff 01 01 01 00
//usb_serial_send_ack(OMMO_ACK_INVALID_MODE);     //05 ff 01 01 ff 00
//usb_serial_send_ack(OMMO_ACK_INVALID_DATA);     //05 ff 01 02 fe 00
//usb_serial_send_ack(OMMO_ACK_UNKNOWN_COMMAND);  //05 ff 01 03 fd 00 


===================================uart init==================================

flow: 

   usb_serial_init -- USBD_Init -- USBD_EnableIAD -- AddCDC -- USBD_CDC_SetOnControlLineState


----------------------------------

main

     
    gpio_init();
 
    usb_serial_init(usb_serial_packet_received, usb_serial_connect_disconnect);


------------------

参数： usb_serial_packet_received, usb_serial_connect_disconnect
usb_serial_init(  br_callback, ev_callback)
 
    packet_received_callback = usb_serial_packet_received;
    event_callback           = usb_serial_connect_disconnect;

    //Init buffers 
    usb_serial_rx_cobs_buffer_top = 0x00;
    usb_serial_rx_packet_ready = false;

    usb_serial_tx_buffer_top = 0x00;
    usb_serial_tx_buffer_active = usb_serial_tx_buffer_primary;
    usb_serial_state_tx_in_progress = false;
    usb_serial_write_force = false;


    usb_serial_state_port_open = false;   //PC DTR
    usb_serial_state_port_dtr = false;

    //Misc
    usb_busy_data_loss_count = 0x00;


    //Fill in serial number
    ommo_usbd_serial_num_generate();

    //Start USB
    USBD_Init();
    USBD_EnableIAD();
    USBD_SetDeviceInfo(&_DeviceInfo);

    _usb_cdc_inst = AddCDC(0, _usb_cdc_rx_raw_buffer, USB_SERIAL_RX_BUFFER_SIZE);
    USBD_CDC_SetOnControlLineState(_usb_cdc_inst, USB_CDC_OnControlLineStateChange);

    USBD_Start();




============================== uart == DTR detect ==================================

flow: 

   main  -- usb_serial_init  -- AddCDC -- USBD_CDC_Add -- (->pfOnClassRequest = _OnClassRequest) 
                             -- USBD_CDC_SetOnControlLineState -- (.pfOnSetControlLineState = USB_CDC_OnControlLineStateChange)

   (?) -- USB__HandleSetup -- _OnClassRequest -- USB_CDC_OnControlLineStateChange -- usb_serial_state_port_dtr (=DTR)  

   usb_serial_event_queue_process -- usb_serial_state_port_open = (TRUE) --  usb_serial_connect_disconnect


数据流：  DTR  -->  usb_serial_state_port_dtr  -->  usb_serial_state_port_open

----------------------------------

main


    usb_serial_init(usb_serial_packet_received, usb_serial_connect_disconnect);



---------------------------------------


参数： usb_serial_packet_received, usb_serial_connect_disconnect
usb_serial_init( br_callback, ev_callback)

    packet_received_callback = usb_serial_packet_received;
    event_callback           = usb_serial_connect_disconnect;

    ......（忽略）

    _usb_cdc_inst = AddCDC(0, _usb_cdc_rx_raw_buffer, USB_SERIAL_RX_BUFFER_SIZE);

    //USBD_CDC_SetOnControlLineState(_usb_cdc_inst, USB_CDC_OnControlLineStateChange);
       _aInst[_usb_cdc_inst].pfOnSetControlLineState = USB_CDC_OnControlLineStateChange;
 
    ......（忽略）



----------

AddCDC(uint8_t ID, uint8_t *buffer, uint16_t buffer_len)

  EPBulkIn.Flags          = 0;                             // Flags not used.
  EPBulkIn.InDir          = USB_DIR_IN;                    // IN direction (Device to Host)
  EPBulkIn.Interval       = 0;                             // Interval not used for Bulk endpoints.
  EPBulkIn.MaxPacketSize  = USB_SERIAL_TX_BUFFER_SIZE;     // Maximum packet size
  EPBulkIn.TransferType   = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.
  InitData.EPIn  = USBD_AddEPEx(&EPBulkIn, NULL, 0);

  EPBulkOut.Flags         = 0;                             // Flags not used.
  EPBulkOut.InDir         = USB_DIR_OUT;                   // OUT direction (Host to Device)
  EPBulkOut.Interval      = 0;                             // Interval not used for Bulk endpoints.
  EPBulkOut.MaxPacketSize = buffer_len;                    // Maximum packet size
  EPBulkOut.TransferType  = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.

  InitData.EPOut = USBD_AddEPEx(&EPBulkOut, buffer, buffer_len); // OUT direction (Host to Device)

  EPIntIn.Flags           = 0;                             // Flags not used.
  EPIntIn.InDir           = USB_DIR_IN;                    // IN direction (Device to Host)
  EPIntIn.Interval        = 64;                            // Interval of 8 ms (64 * 125us)
  EPIntIn.MaxPacketSize   = 16;                            // Maximum packet size for Interrupt.
  EPIntIn.TransferType    = USB_TRANSFER_TYPE_INT;         // Endpoint type - Interrupt.
  InitData.EPInt = USBD_AddEPEx(&EPIntIn, NULL, 0);

  hInst = USBD_CDC_Add(&InitData);   //here
  return hInst


----------------------

USBD_CDC_Add( * pInitData)

   ......

   pInterface->pfOnClassRequest = _OnClassRequest;



----------------------------------------------------------


USB__HandleSetup(* pSetupPacket) 

  ......

  switch(pSetupPacket->bmRequestType & 0x60u) {  // Mask off unnecessary bits
  case 0x20:

    ......

    if (pInterface != NULL)  
      if (pInterface->pfOnClassRequest != NULL)  
          //pInterface->pfOnClassRequest(pSetupPacket);
             _OnClassRequest(pSetupPacket); 
          
 
----------


_OnClassRequest(const USB_SETUP_PACKET * pSetupPacket)  


  InterfaceNum = pSetupPacket->wIndexLow | (pSetupPacket->wIndexHigh << 8);
  Inst         = _InterfaceNum2Inst(InterfaceNum);

  pInst        = &_aInst[Inst];

  switch (pSetupPacket->bRequest) 
  
  case SET_USB_CDC_LINE_CODING:
    ...
  case GET_USB_CDC_LINE_CODING:
    ...
  case SET_CONTROL_LINE_STATE:

    USB_LOG((USB_MTYPE_CDC,  "CDC: SET_CONTROL_LINE_STATE %X", pSetupPacket->wValueLow));

    if (pInst->pfOnSetControlLineState != NULL) 
      USB_CDC_CONTROL_LINE_STATE CLState;

      CLState.DTR = pSetupPacket->wValueLow & 1u;
      CLState.RTS = (pSetupPacket->wValueLow >> 1) & 1u;

      //pInst->pfOnSetControlLineState(&CLState);
         USB_CDC_OnControlLineStateChange(&CLState);

    
    USBD_WriteEP0FromISR(NULL, 0, 1);
    break;
  case SEND_BREAK:
    ...


---------

USB_CDC_OnControlLineStateChange( * pLineState)

    usb_serial_state_port_dtr = pLineState->DTR;   //取得DTR的打开状态


----------

usb_serial_event_queue_process()


    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);  //确认无已触发待处理的中断

    
    if(usb_serial_state_port_dtr && !usb_serial_state_port_open) //DTR打开，亮蓝灯
    
        usb_serial_state_port_dtr = true;
        usb_serial_state_port_open = true;   //DTR open


        if(usb_serial_timeout_gen != NULL)
            APP_ERROR_CHECK(usb_serial_timeout_gen->set_timeout(usb_serial_buffer_flush_timeout_channel, MS_TO_RTC_TIMEOUT_GEN(500)));

        // Setup first transfer buffer
        _io_context_read.NumBytesToTransfer = USB_SERIAL_RX_BUFFER_SIZE;  // 3 * 1024
        _io_context_read.pData = usb_serial_rx_raw_buffer;
        _io_context_read.pfOnComplete = USBD_ReadCompleteCb;

        USBD_CDC_ReadAsync(_usb_cdc_inst, &_io_context_read, true);
    
        if(event_callback != NULL)
        
           //(*event_callback)(USB_SERIAL_EVENT_PORT_OPEN);    
              usb_serial_connect_disconnect(USB_SERIAL_EVENT_PORT_OPEN);   

    
    else if(!usb_serial_state_port_dtr && usb_serial_state_port_open)  //DTR关闭
    
        usb_serial_state_port_dtr = false;
        usb_serial_state_port_open = false;

        USBD_CDC_CancelWrite(_usb_cdc_inst);
        USBD_CDC_CancelRead(_usb_cdc_inst);

        usb_serial_state_tx_in_progress = false;
        usb_serial_clear_tx_buffer();
        usb_serial_clear_cobs_rx_buffer();

        if(usb_serial_timeout_gen != NULL)
            APP_ERROR_CHECK(usb_serial_timeout_gen->disable_timeout(usb_serial_buffer_flush_timeout_channel));

        if(event_callback != NULL)
        
            //(*event_callback)(USB_SERIAL_EVENT_PORT_CLOSE);
                usb_serial_connect_disconnect(USB_SERIAL_EVENT_PORT_CLOSE);

        
------------


usb_serial_connect_disconnect(usb_serial_event event)

    set_leds();

    switch(event)
     
        case USB_SERIAL_EVENT_PORT_CLOSE:
            //Disable data mode on disconnect
            if(data_mode_enabled)
                data_mode_enable(false);

            if(!leave_motor_on)
                stop_motor();

            if(esb_enabled)
             
                comms_esb_disable();
                esb_enabled = false;
             
            break;

        case USB_SERIAL_EVENT_PORT_SUSPEND:
            //Disable data mode on disconnect
            if(data_mode_enabled)
                data_mode_enable(false);

            if(!leave_motor_on)
                stop_motor();
            break;

        case USB_SERIAL_EVENT_PORT_OPEN:
            break;
    
    
    //Clear good id bifield on all usb connection/disconnections
    comms_esb_set_good_id_bitfield(0x00);
 
       


======================================== uart ==== tx ====================================

flow：

   main -- 电脑打开DTR -- usb_serial_write -- (DTR open =true) -- usb_serial_event_queue_process -- USBD_WriteAsync -- USBD_WriteOverlapped -- USBD_PROFILE_CALL_U32x4


数据流："abcde"  -->  usb_serial_tx_buffer_active  -->  filled_buffer  -->  _io_context_write.pData  -->  EPIn（USB端点） 
数据流2：usb_serial_tx_buffer_top  -->  filled_buffer_size  -->  _io_context_write.NumBytesToTransfer
 

--------------------------------------------------------------

main     

    while(1)   

        nrf_delay_ms(10);

        usb_serial_write((uint8_t*)"abcde",5);
        
        usb_serial_event_queue_process();


-------------------

参数： "abcde"  ,  5
数据流： "abcde"  -->  usb_serial_tx_buffer_active -->  usb_serial_tx_buffer_primary
usb_serial_write( *buffer,   length)

    if(!usb_serial_state_port_open)   //DTR关，显示红灯，并退出
        main_led.set_basic(LED_DRIVER_ON_STEADY,RGB_RED(255));  
        main_led.event_queue_process();                           
        return NRFX_SUCCESS;
     
    else                               //DTR开，显示绿灯
        main_led.set_basic(LED_DRIVER_ON_STEADY,RGB_GREEN(255));   
        main_led.event_queue_process();                            
    

    //把"abcde" 存入到发送缓冲区 usb_serial_tx_buffer_active
    if( (usb_serial_tx_buffer_top + length) < USB_SERIAL_TX_BUFFER_SIZE )
    
        usb_serial_tx_buffer_top += length;

        memcpy(usb_serial_tx_buffer_active + usb_serial_tx_buffer_top - length, buffer, length);



------------


数据流：usb_serial_tx_buffer_active  -->  filled_buffer  -->  _io_context_write.pData
数据流2：usb_serial_tx_buffer_top  -->  filled_buffer_size   -->  _io_context_write.NumBytesToTransfer
usb_serial_event_queue_process()

    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);  //确认无已触发待处理的中断
    

    if(usb_serial_state_port_dtr && !usb_serial_state_port_open) //DTR打开，亮蓝灯
    
        ......(略)        


    //Check for data to transmit
    if(usb_serial_state_port_open)
 

        //Check if we have enough data to TX, or we need to force a packet out NOW
        if( (usb_serial_tx_buffer_top > OMMO_USB_SERIAL_MIN_PACKET_SIZE || (usb_serial_write_force && usb_serial_tx_buffer_top > 0)) &&
            !usb_serial_state_tx_in_progress)
        
            //Don't need to send anything again for at least 500ms            
            if(usb_serial_timeout_gen != NULL)
                APP_ERROR_CHECK(usb_serial_timeout_gen->reset_timeout(usb_serial_buffer_flush_timeout_channel));

            uint8_t *filled_buffer = usb_serial_tx_buffer_active;
            uint16_t filled_buffer_size = usb_serial_tx_buffer_top;

            //Switch buffers while DMA writes to USB port
            usb_serial_tx_buffer_top = 0x00;
            if(usb_serial_tx_buffer_active == usb_serial_tx_buffer_primary)
                usb_serial_tx_buffer_active = usb_serial_tx_buffer_secondary;
            else
                usb_serial_tx_buffer_active = usb_serial_tx_buffer_primary;

            //Buffer ready, start the write
            usb_serial_state_tx_in_progress = true;


            _io_context_write.NumBytesToTransfer = filled_buffer_size;
            _io_context_write.pData = filled_buffer;
            _io_context_write.pfOnComplete = USBD_WriteCompleteCb;

            //USBD_CDC_WriteAsync(_usb_cdc_inst, &_io_context_write, usb_serial_write_force);
                 USBD_WriteAsync(_aInst[hInst].EPIn, _io_context_write, usb_serial_write_force );  //here


            usb_serial_write_force = false;
 

----------

参数： _aInst[_usb_cdc_inst].EPIn, _io_context_write, usb_serial_write_force 
USBD_WriteAsync(  EPIndex,   * pContext,   Send0PacketIfRequired)  

  ASYNC_HOOK * pHook;

  pContext->NumBytesTransferred = 0;

  USB_OS_IncDI();                                                //进入屏蔽干扰  （待验证）

  if (USB_aEPStat[EPIndex].Dir.TxInfo.NumDataParts != 0) 
    r = USB_STATUS_EP_BUSY;                                        //-4
   
  else 
    pHook = _InstallAsyncHook(EPIndex);

    r = USBD_WriteOverlapped(EPIndex, pContext->pData, pContext->NumBytesToTransfer, Send0PacketIfRequired);

    if (r >= 0)  
      pHook->NumBytesToTransfer = pContext->NumBytesToTransfer;
      pHook->pIOContext = pContext;
     
  
  USB_OS_DecRI();                                               //退出屏蔽干扰（待验证）


  if (r < 0)  
    pContext->Status = r;
    pContext->pfOnComplete(pContext);
   
 
---------  

功能: 写数据到usb端点
参数：  EPIn, _io_context_write.pData, *.NumBytesToTransfer, Send0PacketIfRequired
数据流：_io_context_write.pData  -->  EPIn（USB端点） 
USBD_WriteOverlapped(  EPIndex,  * pData,  NumBytes,   Send0PacketIfRequired)  
  EP_STAT * pEPStat;

  USB_DATA_PART *pPart;

  USBD_PROFILE_CALL_U32x4(USBD_EVTID_WRITEOVERLAPPED, EPIndex, pData, NumBytes, Send0PacketIfRequired);  //发送数据到USB端点

  if ((USB_Global.State & (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) != USB_STAT_CONFIGURED)      //lint !e9032 N:100
    return USB_STATUS_ERROR;
   

  pEPStat = &USB_aEPStat[EPIndex];
  if (pEPStat->IsHalted != 0)  
    return USB_STATUS_EP_HALTED;
   
  USB_OS_IncDI();
  
  // Check if a transfer is in progress. In this case,
  // we either extend the running transfer or queue another transfer.
  // If the queue is full, we return USB_STATUS_EP_BUSY.
   
  pPart = &pEPStat->Dir.TxInfo.DataParts[0];

  if (pEPStat->Dir.TxInfo.NumDataParts != 0u) 

    pPart += (pEPStat->Dir.TxInfo.NumDataParts - 1u);
    if ((pEPStat->Dir.TxInfo.WriteMode & USB_WRITE_MODE_EXTEND) != 0u && pPart->pData + pPart->NumBytesRem == *pData)  
       
      // Extend current transfer
       
      pPart->NumBytesRem += NumBytes;
      pEPStat->Dir.TxInfo.Send0PacketIfRequired =  Send0PacketIfRequired;
      r = 0;
      goto Done;
    
  
    // Check for a free slot.

    if (pEPStat->Dir.TxInfo.NumDataParts == USB_NUM_TX_DATA_PARTS)  
      r = USB_STATUS_EP_BUSY;
      goto Done;
    

    // Move to next free slot
  
    pPart++;
  

  // Put new request into queue.

  pPart->pData       = *pData;
  pPart->NumBytesRem = NumBytes;
  pEPStat->Dir.TxInfo.NumDataParts++;
  pEPStat->Dir.TxInfo.Send0PacketIfRequired =Send0PacketIfRequired;
  pEPStat->TransactionCnt = ++USB_Global.TransactionCnt;


  // If no transfer in progress, start one

  if (pEPStat->Dir.TxInfo.TxNumBytesPending == 0)   
    USB_Global.pDriver->pfStartTx(EPIndex);
   
  r = 0;

Done:
  USB_OS_DecRI();
  USBD_PROFILE_END_CALL_U32(USBD_EVTID_WRITEOVERLAPPED, r);





=================================== uart ==== rx ===============================


flow: 

   main -- usb_serial_init -- (packet_received_callback = usb_serial_packet_received) -- usb_serial_event_queue_process      // read rxdata 
        -- (.pfOnComplete = USBD_ReadCompleteCb) -- USBD_CDC_ReadAsync -- USBD_ReadCompleteCb -- cobs_decode_crc                                                      

   main -- usb_serial_event_queue_process -- usb_serial_packet_received -- usb_serial_send_command_packet                     // dowith rxdata


数据流：usb  -->  usb_serial_rx_raw_buffer  --> usb_serial_rx_cobs_buffe   -->  usb_serial_rx_packet_buffer
数据流：usb  --> _io_context_read.NumBytesTransferred  -->  usb_serial_rx_packet_length  

-----------------------------------------------------------------

测试rx data: 31 32 33 34 35 36 37 38 39 00

rx_row_buffer:
61 62 63 64 65 30 30 30 30 20 61 62 63 64 65 30 30 30 30 20     31 32 33 34 35 36 37 38 39 00     05 FF 01 03 FD 00 

rx_cobs_buffer:
61 62 63 64 65 30 30 30 30 20 61 62 63 64 65 30 30 30 30 20     31 32 33 34 35 36 37 38 39 00     05 FF 01 03 FD 00 

rx_packet_buffer:
61 62 63 64 65 30 30 30 30 20 61 62 63 64 65 30 30 30 30 20        32 33 34 35 36 37 38           05 FF 01 03 FD 00 


-----------------------------------------------------------------



main


    usb_serial_init(usb_serial_packet_received, usb_serial_connect_disconnect);


    while(1)


       usb_serial_event_queue_process();



--------------

参数： usb_serial_packet_received, usb_serial_connect_disconnect
usb_serial_init(  br_callback, ev_callback)
 
    packet_received_callback = usb_serial_packet_received;       //here
    event_callback           = usb_serial_connect_disconnect;

    ...... (忽略)


    _usb_cdc_inst = AddCDC(0, _usb_cdc_rx_raw_buffer, USB_SERIAL_RX_BUFFER_SIZE);        //here
    USBD_CDC_SetOnControlLineState(_usb_cdc_inst, USB_CDC_OnControlLineStateChange);

    USBD_Start();



-----------------------

功能：检测usb打开，读取usb数据
数据流：usb  --> _io_context_read.pData  --> usb_serial_rx_raw_buffer 
数据流：usb  --> _io_context_read.NumBytesTransferred      
usb_serial_event_queue_process()

    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);   //确定无中断冲突
    
    if(usb_serial_state_port_dtr && !usb_serial_state_port_open)   //DTR打开，亮蓝灯
    
        usb_serial_state_port_dtr = true;
        usb_serial_state_port_open = true;   //DTRV open


        if(usb_serial_timeout_gen != NULL)
            APP_ERROR_CHECK(usb_serial_timeout_gen->set_timeout(usb_serial_buffer_flush_timeout_channel, MS_TO_RTC_TIMEOUT_GEN(500)));

        // Setup first transfer buffer
        _io_context_read.NumBytesToTransfer = USB_SERIAL_RX_BUFFER_SIZE;  // 3 * 1024
        _io_context_read.pData = usb_serial_rx_raw_buffer;

        _io_context_read.pfOnComplete = USBD_ReadCompleteCb;

        //USBD_CDC_ReadAsync(_usb_cdc_inst, &_io_context_read, true);                       //here， 读取usb数据
           //USBD_ReadAsync(_aInst[hInst].EPOut, _io_context_read, ShortRead);
              //USB__Read(EPIndex, pContext->pData, pHook->NumBytesToTransfer, 0, Mode);    //数据流：usb --> pContext->pData(usb_serial_rx_raw_buffer)
              //   USBD_BUFFER_Read(&pEPStat->Dir.RxInfo.Buffer, pData, NumBytesReq);        //数据流： Buffer --> pData  
                       USB_MEMCPY(pData, pBuffer->pData + pBuffer->RdPos, NumBytesAtOnce);    //数据流： pBuffer --> pData  
              //pContext->pfOnComplete(_io_context_read);
                  USBD_ReadCompleteCb(_io_context_read);
    

        if(event_callback != NULL)
        
            //(*event_callback)(USB_SERIAL_EVENT_PORT_OPEN);    
                  usb_serial_connect_disconnect(USB_SERIAL_EVENT_PORT_OPEN);  



-------------------


功能： 取得usb_serial_rx_packet_buffer接收包
数据流：usb_serial_rx_raw_buffer --> usb_serial_rx_cobs_buffer  -->  usb_serial_rx_packet_buffer
数据流：_io_context_read.NumBytesTransferred  -->  usb_serial_rx_packet_length
参数： _io_context_read
USBD_ReadCompleteCb( *pIOContext)

    for(uint16_t i = 0; i < pIOContext->NumBytesTransferred && usb_serial_rx_cobs_buffer_top<USB_SERIAL_RX_BUFFER_SIZE; i++)
    
        usb_serial_rx_cobs_buffer[usb_serial_rx_cobs_buffer_top++] = usb_serial_rx_raw_buffer[i]; //数据流：sb_serial_rx_raw_buffer -> usb_serial_rx_cobs_buffer 
        if(usb_serial_rx_raw_buffer[i] == 0x00) //End of packet
        
            uint8_t crc;
            size_t packet_size, not_used;

            //Is packet buffer busy
            if(!usb_serial_rx_packet_ready)
            
                //Decode our rx cobs buffer
                cobs_decode_crc(usb_serial_rx_cobs_buffer, usb_serial_rx_cobs_buffer_top - 1,  //数据流：usb_serial_rx_cobs_buffer -> usb_serial_rx_packet_buffer
                                 usb_serial_rx_packet_buffer,USB_SERIAL_RX_BUFFER_SIZE, &crc, &not_used, &packet_size); 

                if(packet_size > 0x00)  //Is this a real packet
                
                    if(crc == 0x00)
                    
                        usb_serial_rx_packet_length = packet_size;
                        usb_serial_rx_packet_ready = true;
                    
                    else
                    
                        usb_serial_send_ack(OMMO_ACK_INVALID_DATA);                    
                
            
            else            
                ;//RX buffer is busy, packet discarded
            

            //Clear our rx cobs buffer
            usb_serial_clear_cobs_rx_buffer();
        
    

    //读取下一次的数据
    if(usb_serial_state_port_open) USBD_CDC_ReadAsync(_usb_cdc_inst, &_io_context_read, 1);



------------

数据流：usb_serial_rx_cobs_buffer -> usb_serial_rx_packet_buffer
数据流：f(*_cobs_buffer_top - 1) -> upacket_size
参数：usb_serial_rx_cobs_buffer, *_cobs_buffer_top - 1, usb_serial_rx_packet_buffer,3*1024, &crc, &not_used, &packet_size
cobs_decode_crc( *ptr, input_length, *dst, dest_buffer_length, *crc, *input_length_used, *dest_length)  //后3个也是输出参数

	const uint8_t *start = dst, *end = ptr + input_length;
	uint8_t code = 0xFF, copy = 0;

        *dest_length = 0;
        *input_length_used = 0;
        *crc = 0;

	for (; ptr < end; copy--)   //待理解

        
            if (*dest_length == dest_buffer_length) // overrun            
                return false;            

            (*input_length_used)++; //Keep track of bytes pulled from input

            if (copy != 0)
            
                uint8_t c = *ptr++;
                
                *dst++ = c;
                (*dest_length)++;

                *crc += c;
            
            else
            
                if (code != 0xFF)
                
                    *dst++ = 0;
                    (*dest_length)++;                

                copy = code = *ptr++;   //待理解

                if (code == 0)
                
                    (*dest_length)--; /* Exclue the 0 terminator from length output */
                    break; /* Source length too long */
                

        /* Exclue the crc from length output */
        if(*dest_length == 0x00)
            return false;
        (*dest_length)--;



--------------

功能：对接收包usb_serial_rx_packet_buffer处理
usb_serial_event_queue_process()

    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);   //确定无中断冲突

    //cdc uart接收数据处理
    if(usb_serial_rx_packet_ready)
    
        usb_serial_rx_packet_ready = false;

        //Check for block_dev requests
        if(usb_serial_rx_packet_buffer[0] == OMMO_COMMAND_BLOCK_DEV_READ)  //18
        
           ......（忽略）
        
        else

           main_led.set_basic(LED_DRIVER_ON_STEADY,RGB_WHITE);  //--test
           main_led.event_queue_process();                      //--test
           nrf_delay_ms(300);   //亮白灯0.3秒
           usb_serial_write_now(usb_serial_rx_packet_buffer,usb_serial_rx_packet_length,0);  //--test ，把收到的数据打印log出来

           if(packet_received_callback != NULL)
        
                //(*packet_received_callback)(usb_serial_rx_packet_buffer, usb_serial_rx_packet_length);
                   usb_serial_packet_received(usb_serial_rx_packet_buffer, usb_serial_rx_packet_length);
        


-----------------------

功能：对接收包usb_serial_rx_packet_buffer处理  
参数：usb_serial_rx_packet_buffer, usb_serial_rx_packet_length  
usb_serial_packet_received( data[], length)

    switch(data[0])
    
        case OMMO_COMMAND_USB_DATA_ENABLE:            //32
            if(data_mode != DATA_MODE_DISABLED)
            
                usb_serial_send_ack(OMMO_ACK_INVALID_MODE);
            
            else if(length != 2)
            
                usb_serial_send_ack(OMMO_ACK_INVALID_DATA);
            
            else
            
                //Try to start state machine
                uint32_t rvalue = adc_cartes_start_state_machine();

                if(rvalue == NRF_SUCCESS)
                
                    packet_id = data[1];
                    data_mode = DATA_MODE_USB;
                
                
                //Return success/failure
                usb_serial_send_ack(convert_nrf_error_code_to_ommo_ack_code(rvalue));
                set_leds();
            
            return;
    

    //Try protocol agnostic processing
    response_length = process_packet_received(data, length, response_buffer, 1024);
   
    if(response_length == 0) //No response, must be an unknown command
        response_length = fill_in_ack_packet(response_buffer, OMMO_ACK_UNKNOWN_COMMAND);

    //usb_serial_send_command_packet(response_buffer, response_length);
    //    usb_serial_send_command_packet_blocking(buffer, length, false);
             length = cobs_encode_usb_command_crc_post0(buffer, length, cobs_buffer);
             usb_serial_write_now(cobs_buffer, length, block);



---------

//立即发送 ，发送完才执行以后的程序
usb_serial_write_now( *buffer,  length,  block)

    usb_serial_write(buffer, length);

    usb_serial_write_force = true;

    if(block)
    
        while(usb_serial_write_force)
        
            usb_serial_event_queue_process();
 



-----------------------

参数 ：usb_serial_rx_packet_buffer,   usb_serial_rx_packet_length ,   response_buffer,    1024
process_packet_received(data[], packet_size, response_buffer[],  response_buffer_size)
 

    switch(data[0])
    
        case OMMO_COMMAND_DATA_DISABLE:
            if(!(data_mode_enabled || enable_data_after_motor_running))
            
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_MODE);
            
            else if(packet_size != 1)
            
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
            
            else
            {
                data_mode_enable(false);

                if(!leave_motor_on)
                    stop_motor();

                return fill_in_ack_packet(response_buffer, OMMO_ACK_SUCCESS);
            }
        
        case OMMO_COMMAND_LEAVE_MOTOR_ON:
            if(packet_size != 2)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
            }
            else
            {
                leave_motor_on = data[1];
                leave_motor_on_routine(leave_motor_on);

                return fill_in_ack_packet(response_buffer, OMMO_ACK_SUCCESS);
            }

        case OMMO_COMMAND_TURN_MOTOR_OFF:
            if(packet_size != 1)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
            }
            else if(!data_mode_enabled)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_MODE);
            }
            else
            {
                stop_motor(false);

                return fill_in_ack_packet(response_buffer, OMMO_ACK_SUCCESS);
            }

        case OMMO_COMMAND_READ_MOTOR_CURRENT:
            if(packet_size != 1)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
            }
            else if(data_mode_enabled || !leave_motor_on)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_MODE);
            }
            else
            {
                uint16_t current = read_motor_current();
                copyUint8(response_buffer, response_length, OMMO_COMMAND_READ_MOTOR_CURRENT);
                copyUint16_LE(response_buffer, response_length, current);
                return response_length;
            }

        case OMMO_COMMAND_GET_PACKET_DESCRIPTOR:
            if(packet_size != 1)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
            }
            else if(data_mode_enabled)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_MODE);
            }

            else
            {
                return fill_in_packet_id_request(response_buffer, response_buffer_size);
            }

        case OMMO_COMMAND_GET_RUNTIME:
            if(packet_size != 1)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
            }
            else
            {
                copyUint8(response_buffer, response_length, OMMO_COMMAND_GET_RUNTIME); //PACKET_ID
                copyUint32_LE(response_buffer, response_length, total_run_time_logger.get_current_ticks());
                copyUint32_LE(response_buffer, response_length, motor_run_time_logger.get_current_ticks());
                return response_length;
            }

        case OMMO_COMMAND_CLEAR_RUNTIME:
            if(packet_size != 2 || data[1] != 0x55)
            {
                return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
            }
            else
            {
                total_run_time_logger.reset();
                motor_run_time_logger.reset();
                return fill_in_ack_packet(response_buffer, OMMO_ACK_SUCCESS);
            }

        case OMMO_COMMAND_SET_MAG_CAL_MODE:
            {
                if(packet_size != 3 || data[1] != 0x55)
                {
                    return fill_in_ack_packet(response_buffer, OMMO_ACK_INVALID_DATA);
                }
                else
                {
                    mag_calibration_mode = data[2];
                    return fill_in_ack_packet(response_buffer, OMMO_ACK_SUCCESS);
                }
            }

    }

    //Try general processor
    response_length = general_process_packet_received(data, packet_size, response_buffer, response_buffer_size);
    if(response_length != 0)  return response_length;

    //Try device info commands
    response_length = device_info_process_packet_received(data, packet_size, response_buffer, response_buffer_size, mag_calibration_mode);
    if(response_length != 0)  return response_length;


}








=========================================参考 =======================================================



------

adc_cartes_start_state_machine()

    adc_cartes_stop_state_machine();

    current_state = SETUP_ADC_START_SAMPLE;
    adc_cartes_state_change();


------

adc_cartes_stop_state_machine( blocking)

    if(current_state != STATE_MACHINE_STOPPED)
    
        stop_state_machine_bit = true;
    
    if(blocking)
    
        while(current_state != STATE_MACHINE_STOPPED)
        
            //This fixes ISR safety issue
            //Will make sure current_state == STATE_MACHINE_STOPPED even interrupts with higher priority jump in
            stop_state_machine_bit = true;
        
        stop_state_machine_bit = false;
    


------

adc_cartes_state_change()

    while(!wait_for_callback)
    
        switch(current_state)
        
            case SETUP_ADC_START_SAMPLE:
                //Start all spi bus's
                for(port = 0; port < OMMO_CARTES_ADC_NUM_PORTS; port++)
                
                    //Setup next ADC sample start packet for PPI to trigger later and switch states
                    adc_cartes_setup_PPI_start_sample_packet(port);
               

                //Enable PPI for all spi channels
                adc_cartes_set_ppi_start_transfer_event_addr(timestamp_get_sample_event_address());
                nrfx_ppi_group_enable(ppi_group_sample_start_spi); //Next PPI will be on sample timer

                //Switch states
                current_state = WAITING_FOR_ADC_START_SAMPLE_COMPLETION;
                wait_for_callback = true;
                break;

            case WAITING_FOR_ADC_START_SAMPLE_COMPLETION:
                //Turn off PPI
                nrfx_ppi_group_disable(ppi_group_sample_start_spi);      

                //Switch states        
                current_state_index = -1;        
                current_state = SETUP_NEXT_ADC_DATA_READ;
                break;

            case SETUP_NEXT_ADC_DATA_READ:
                current_state_index++;
                if(current_state_index < num_ports_with_adc)
                
                    //Start the SPI mag data read on busses with mags
                    if(ADC_PRESENT(ports_with_adc[current_state_index]))
                        adc_cartes_start_data_read(ports_with_adc[current_state_index]);

                  //Wait for data read to finish
                  current_state = WAITING_FOR_ADC_DATA_READ_COMPLETION;
                  wait_for_callback = true;
                
                else

                    current_state = SETUP_STATE_MACHINE_RESTART;


            case WAITING_FOR_ADC_DATA_READ_COMPLETION:
                //Save read data
                if(ADC_PRESENT(ports_with_adc[current_state_index]))
                
                    len = ic_data[ss_map[ports_with_adc[current_state_index]]].data_length;
                    offset = ic_data[ss_map[ports_with_adc[current_state_index]]].data_offset;
                    memcpy(current_output_data + data_output_index[ports_with_adc[current_state_index]], m_twi_rx_buf[ports_with_adc[current_state_index]]+offset, len);
                
                current_state = SETUP_NEXT_ADC_DATA_READ;


            case SETUP_STATE_MACHINE_RESTART:
                if(stop_state_machine_bit)
                
                    stop_state_machine_bit = false;
                    current_state = STATE_MACHINE_STOPPED;
                    wait_for_callback = true;
                
                else
                
                    //swap buffers
                    swap_sample_buffers_and_flag_sample_callback();
                    current_state = SETUP_ADC_START_SAMPLE;


            default:
                APP_ERROR_HANDLER(NRF_ERROR_INTERNAL);
  















