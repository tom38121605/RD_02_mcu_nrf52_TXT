
注意1： 用sscom串口助手调试，需勾选 DTR


usb_serial_write((uint8_t*)"12345abcde",10);


============================uart init===========================

flow: 


----------------------------------

main

     
    gpio_init();
 
    usb_serial_init(usb_serial_packet_received, usb_serial_connect_disconnect);


------------------

参数： usb_serial_packet_received, usb_serial_connect_disconnect
usb_serial_init(  br_callback, ev_callback)
 
    packet_received_callback = usb_serial_packet_received;
    event_callback           = usb_serial_connect_disconnect;

    //Init buffers 
    usb_serial_rx_cobs_buffer_top = 0x00;
    usb_serial_rx_packet_ready = false;

    usb_serial_tx_buffer_top = 0x00;
    usb_serial_tx_buffer_active = usb_serial_tx_buffer_primary;
    usb_serial_state_tx_in_progress = false;
    usb_serial_write_force = false;


    usb_serial_state_port_open = false;   //PC DTR
    usb_serial_state_port_dtr = false;

    //Misc
    usb_busy_data_loss_count = 0x00;


    //Fill in serial number
    ommo_usbd_serial_num_generate();

    //Start USB
    USBD_Init();
    USBD_EnableIAD();
    USBD_SetDeviceInfo(&_DeviceInfo);

    _usb_cdc_inst = AddCDC(0, _usb_cdc_rx_raw_buffer, USB_SERIAL_RX_BUFFER_SIZE);
    USBD_CDC_SetOnControlLineState(_usb_cdc_inst, USB_CDC_OnControlLineStateChange);

    USBD_Start();






======================= uart == DTR detect ===========================

flow: 

   main  -- usb_serial_init -- USB_CDC_OnControlLineStateChange  -- AddCDC -- USBD_CDC_Add  

   (?) -- USB__HandleSetup -- _OnClassRequest -- USB_CDC_OnControlLineStateChange -- usb_serial_state_port_dtr (=DTR)  

   usb_serial_event_queue_process  --  usb_serial_state_port_open = (TRUE) --  usb_serial_connect_disconnect


数据流：  DTR  -->  usb_serial_state_port_dtr  -->  usb_serial_state_port_open

----------------------------------

main


    usb_serial_init(usb_serial_packet_received, usb_serial_connect_disconnect);



---------------------------------------


参数： usb_serial_packet_received, usb_serial_connect_disconnect
usb_serial_init( br_callback, ev_callback)

    packet_received_callback = usb_serial_packet_received;
    event_callback           = usb_serial_connect_disconnect;

    ......（忽略）

    _usb_cdc_inst = AddCDC(0, _usb_cdc_rx_raw_buffer, USB_SERIAL_RX_BUFFER_SIZE);

    //USBD_CDC_SetOnControlLineState(_usb_cdc_inst, USB_CDC_OnControlLineStateChange);
       _aInst[_usb_cdc_inst].pfOnSetControlLineState = USB_CDC_OnControlLineStateChange;
 
    ......（忽略）



---------

USB_CDC_OnControlLineStateChange( * pLineState)

    usb_serial_state_port_dtr = pLineState->DTR;   //取得DTR的打开状态


----------

AddCDC(uint8_t ID, uint8_t *buffer, uint16_t buffer_len)

  EPBulkIn.Flags          = 0;                             // Flags not used.
  EPBulkIn.InDir          = USB_DIR_IN;                    // IN direction (Device to Host)
  EPBulkIn.Interval       = 0;                             // Interval not used for Bulk endpoints.
  EPBulkIn.MaxPacketSize  = USB_SERIAL_TX_BUFFER_SIZE;     // Maximum packet size
  EPBulkIn.TransferType   = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.
  InitData.EPIn  = USBD_AddEPEx(&EPBulkIn, NULL, 0);

  EPBulkOut.Flags         = 0;                             // Flags not used.
  EPBulkOut.InDir         = USB_DIR_OUT;                   // OUT direction (Host to Device)
  EPBulkOut.Interval      = 0;                             // Interval not used for Bulk endpoints.
  EPBulkOut.MaxPacketSize = buffer_len;                    // Maximum packet size
  EPBulkOut.TransferType  = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.

  InitData.EPOut = USBD_AddEPEx(&EPBulkOut, buffer, buffer_len); // OUT direction (Host to Device)

  EPIntIn.Flags           = 0;                             // Flags not used.
  EPIntIn.InDir           = USB_DIR_IN;                    // IN direction (Device to Host)
  EPIntIn.Interval        = 64;                            // Interval of 8 ms (64 * 125us)
  EPIntIn.MaxPacketSize   = 16;                            // Maximum packet size for Interrupt.
  EPIntIn.TransferType    = USB_TRANSFER_TYPE_INT;         // Endpoint type - Interrupt.
  InitData.EPInt = USBD_AddEPEx(&EPIntIn, NULL, 0);

  hInst = USBD_CDC_Add(&InitData);   //here
  return hInst


----------------------

USBD_CDC_Add( * pInitData)

  ......

  pInterface->pfOnClassRequest = _OnClassRequest;



----------------------------------------------------------


USB__HandleSetup(* pSetupPacket) 

  ......

  switch(pSetupPacket->bmRequestType & 0x60u) {  // Mask off unnecessary bits
  case 0x20:

    ......

    if (pInterface != NULL)  
      if (pInterface->pfOnClassRequest != NULL)  
          //pInterface->pfOnClassRequest(pSetupPacket);
             _OnClassRequest(pSetupPacket); 
          
 
----------


_OnClassRequest(const USB_SETUP_PACKET * pSetupPacket)  


  InterfaceNum = pSetupPacket->wIndexLow | (pSetupPacket->wIndexHigh << 8);
  Inst         = _InterfaceNum2Inst(InterfaceNum);

  pInst        = &_aInst[Inst];

  switch (pSetupPacket->bRequest) 
  
  case SET_USB_CDC_LINE_CODING:
    ...
  case GET_USB_CDC_LINE_CODING:
    ...
  case SET_CONTROL_LINE_STATE:

    USB_LOG((USB_MTYPE_CDC,  "CDC: SET_CONTROL_LINE_STATE %X", pSetupPacket->wValueLow));

    if (pInst->pfOnSetControlLineState != NULL) 
      USB_CDC_CONTROL_LINE_STATE CLState;

      CLState.DTR = pSetupPacket->wValueLow & 1u;
      CLState.RTS = (pSetupPacket->wValueLow >> 1) & 1u;

      //pInst->pfOnSetControlLineState(&CLState);
         USB_CDC_OnControlLineStateChange(&CLState);

    
    USBD_WriteEP0FromISR(NULL, 0, 1);
    break;
  case SEND_BREAK:
    ...
.

----------

usb_serial_event_queue_process()


    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);  //确认无已触发待处理的中断

    
    if(usb_serial_state_port_dtr && !usb_serial_state_port_open) //DTR打开，亮蓝灯
    
        usb_serial_state_port_dtr = true;
        usb_serial_state_port_open = true;   //DTR open


        if(usb_serial_timeout_gen != NULL)
            APP_ERROR_CHECK(usb_serial_timeout_gen->set_timeout(usb_serial_buffer_flush_timeout_channel, MS_TO_RTC_TIMEOUT_GEN(500)));

        // Setup first transfer buffer
        _io_context_read.NumBytesToTransfer = USB_SERIAL_RX_BUFFER_SIZE;  // 3 * 1024
        _io_context_read.pData = usb_serial_rx_raw_buffer;
        _io_context_read.pfOnComplete = USBD_ReadCompleteCb;

        USBD_CDC_ReadAsync(_usb_cdc_inst, &_io_context_read, true);
    
        if(event_callback != NULL)
        
           //(*event_callback)(USB_SERIAL_EVENT_PORT_OPEN);    
              usb_serial_connect_disconnect(USB_SERIAL_EVENT_PORT_OPEN);   

    
    else if(!usb_serial_state_port_dtr && usb_serial_state_port_open)  //DTR关闭
    
        usb_serial_state_port_dtr = false;
        usb_serial_state_port_open = false;

        USBD_CDC_CancelWrite(_usb_cdc_inst);
        USBD_CDC_CancelRead(_usb_cdc_inst);

        usb_serial_state_tx_in_progress = false;
        usb_serial_clear_tx_buffer();
        usb_serial_clear_cobs_rx_buffer();

        if(usb_serial_timeout_gen != NULL)
            APP_ERROR_CHECK(usb_serial_timeout_gen->disable_timeout(usb_serial_buffer_flush_timeout_channel));

        if(event_callback != NULL)
        
            //(*event_callback)(USB_SERIAL_EVENT_PORT_CLOSE);
                usb_serial_connect_disconnect(USB_SERIAL_EVENT_PORT_CLOSE);

        
------------


usb_serial_connect_disconnect(usb_serial_event event)

    set_leds();

    switch(event)
     
        case USB_SERIAL_EVENT_PORT_CLOSE:
            //Disable data mode on disconnect
            if(data_mode_enabled)
                data_mode_enable(false);

            if(!leave_motor_on)
                stop_motor();

            if(esb_enabled)
             
                comms_esb_disable();
                esb_enabled = false;
             
            break;

        case USB_SERIAL_EVENT_PORT_SUSPEND:
            //Disable data mode on disconnect
            if(data_mode_enabled)
                data_mode_enable(false);

            if(!leave_motor_on)
                stop_motor();
            break;

        case USB_SERIAL_EVENT_PORT_OPEN:
            break;
    
    
    //Clear good id bifield on all usb connection/disconnections
    comms_esb_set_good_id_bitfield(0x00);
 

       



       



================================= uart ==== tx =============================

flow：

   main -- 电脑打开DTR -- usb_serial_write -- (DTR open =true) -- usb_serial_event_queue_process -- USBD_WriteAsync -- USBD_WriteOverlapped -- USBD_PROFILE_CALL_U32x4


数据流："abcde"  -->  usb_serial_tx_buffer_active  -->  filled_buffer  -->  _io_context_write.pData   -->  EPIn（USB端点） 
数据流2：usb_serial_tx_buffer_top  -->  filled_buffer_size   -->  _io_context_write.NumBytesToTransfer
 

--------------------------------------------------------------

main     

    while(1)   

        nrf_delay_ms(10);

        usb_serial_write((uint8_t*)"abcde",5);
        
        usb_serial_event_queue_process();


-------------------

参数： "abcde"  ,  5
数据流： "abcde"  -->  usb_serial_tx_buffer_active -->  usb_serial_tx_buffer_primary
usb_serial_write( *buffer,   length)

    if(!usb_serial_state_port_open)   //DTR关，显示红灯，并退出
        main_led.set_basic(LED_DRIVER_ON_STEADY,RGB_RED(255));  
        main_led.event_queue_process();                           
        return NRFX_SUCCESS;
     
    else                               //DTR开，显示绿灯
        main_led.set_basic(LED_DRIVER_ON_STEADY,RGB_GREEN(255));   
        main_led.event_queue_process();                            
    

    //把"abcde" 存入到发送缓冲区 usb_serial_tx_buffer_active
    if( (usb_serial_tx_buffer_top + length) < USB_SERIAL_TX_BUFFER_SIZE )
    
        usb_serial_tx_buffer_top += length;

        memcpy(usb_serial_tx_buffer_active + usb_serial_tx_buffer_top - length, buffer, length);



------------


数据流：usb_serial_tx_buffer_active  -->  filled_buffer  -->  _io_context_write.pData
数据流2：usb_serial_tx_buffer_top  -->  filled_buffer_size   -->  _io_context_write.NumBytesToTransfer
usb_serial_event_queue_process()

    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);  //确认无已触发待处理的中断
    

    if(usb_serial_state_port_dtr && !usb_serial_state_port_open) //DTR打开，亮蓝灯
    
        ......(略)        


    //Check for data to transmit
    if(usb_serial_state_port_open)
 

        //Check if we have enough data to TX, or we need to force a packet out NOW
        if( (usb_serial_tx_buffer_top > OMMO_USB_SERIAL_MIN_PACKET_SIZE || (usb_serial_write_force && usb_serial_tx_buffer_top > 0)) &&
            !usb_serial_state_tx_in_progress)
        
            //Don't need to send anything again for at least 500ms            
            if(usb_serial_timeout_gen != NULL)
                APP_ERROR_CHECK(usb_serial_timeout_gen->reset_timeout(usb_serial_buffer_flush_timeout_channel));

            uint8_t *filled_buffer = usb_serial_tx_buffer_active;
            uint16_t filled_buffer_size = usb_serial_tx_buffer_top;

            //Switch buffers while DMA writes to USB port
            usb_serial_tx_buffer_top = 0x00;
            if(usb_serial_tx_buffer_active == usb_serial_tx_buffer_primary)
                usb_serial_tx_buffer_active = usb_serial_tx_buffer_secondary;
            else
                usb_serial_tx_buffer_active = usb_serial_tx_buffer_primary;

            //Buffer ready, start the write
            usb_serial_state_tx_in_progress = true;


            _io_context_write.NumBytesToTransfer = filled_buffer_size;
            _io_context_write.pData = filled_buffer;
            _io_context_write.pfOnComplete = USBD_WriteCompleteCb;

            //USBD_CDC_WriteAsync(_usb_cdc_inst, &_io_context_write, usb_serial_write_force);
                 USBD_WriteAsync(_aInst[hInst].EPIn, _io_context_write, usb_serial_write_force );  //here


            //If we were sending a forced packet, we are finished 
            usb_serial_write_force = false;
 

----------

参数： _aInst[_usb_cdc_inst].EPIn, _io_context_write, usb_serial_write_force 
USBD_WriteAsync(  EPIndex,   * pContext,   Send0PacketIfRequired)  

  ASYNC_HOOK * pHook;

  pContext->NumBytesTransferred = 0;

  USB_OS_IncDI();                                                //进入屏蔽干扰  （待验证）

  if (USB_aEPStat[EPIndex].Dir.TxInfo.NumDataParts != 0) 
    r = USB_STATUS_EP_BUSY;                                        //-4
   
  else 
    pHook = _InstallAsyncHook(EPIndex);

    r = USBD_WriteOverlapped(EPIndex, pContext->pData, pContext->NumBytesToTransfer, Send0PacketIfRequired);

    if (r >= 0)  
      pHook->NumBytesToTransfer = pContext->NumBytesToTransfer;
      pHook->pIOContext = pContext;
     
  
  USB_OS_DecRI();                                               //退出屏蔽干扰（待验证）


  if (r < 0)  
    pContext->Status = r;
    pContext->pfOnComplete(pContext);
   
 
---------  

功能: 写数据到usb端点
参数：  EPIn, _io_context_write.pData, *.NumBytesToTransfer, Send0PacketIfRequired
数据流：_io_context_write.pData  -->  EPIn（USB端点） 
USBD_WriteOverlapped(  EPIndex,  * pData,  NumBytes,   Send0PacketIfRequired)  
  EP_STAT * pEPStat;

  USB_DATA_PART *pPart;

  USBD_PROFILE_CALL_U32x4(USBD_EVTID_WRITEOVERLAPPED, EPIndex, pData, NumBytes, Send0PacketIfRequired);  //发送数据到USB端点

  if ((USB_Global.State & (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) != USB_STAT_CONFIGURED)      //lint !e9032 N:100
    return USB_STATUS_ERROR;
   

  pEPStat = &USB_aEPStat[EPIndex];
  if (pEPStat->IsHalted != 0)  
    return USB_STATUS_EP_HALTED;
   
  USB_OS_IncDI();
  
  // Check if a transfer is in progress. In this case,
  // we either extend the running transfer or queue another transfer.
  // If the queue is full, we return USB_STATUS_EP_BUSY.
   
  pPart = &pEPStat->Dir.TxInfo.DataParts[0];

  if (pEPStat->Dir.TxInfo.NumDataParts != 0u) 

    pPart += (pEPStat->Dir.TxInfo.NumDataParts - 1u);
    if ((pEPStat->Dir.TxInfo.WriteMode & USB_WRITE_MODE_EXTEND) != 0u && pPart->pData + pPart->NumBytesRem == *pData)  
       
      // Extend current transfer
       
      pPart->NumBytesRem += NumBytes;
      pEPStat->Dir.TxInfo.Send0PacketIfRequired =  Send0PacketIfRequired;
      r = 0;
      goto Done;
    
  
    // Check for a free slot.

    if (pEPStat->Dir.TxInfo.NumDataParts == USB_NUM_TX_DATA_PARTS)  
      r = USB_STATUS_EP_BUSY;
      goto Done;
    

    // Move to next free slot
  
    pPart++;
  


  // Put new request into queue.

  pPart->pData       = *pData;
  pPart->NumBytesRem = NumBytes;
  pEPStat->Dir.TxInfo.NumDataParts++;
  pEPStat->Dir.TxInfo.Send0PacketIfRequired =Send0PacketIfRequired;
  pEPStat->TransactionCnt = ++USB_Global.TransactionCnt;


  // If no transfer in progress, start one

  if (pEPStat->Dir.TxInfo.TxNumBytesPending == 0)   
    USB_Global.pDriver->pfStartTx(EPIndex);
   
  r = 0;

Done:
  USB_OS_DecRI();
  USBD_PROFILE_END_CALL_U32(USBD_EVTID_WRITEOVERLAPPED, r);






============================ uart ==== rx ========================


flow: 

   main  --  usb_serial_init  --  usb_serial_event_queue_process  --  USBD_CDC_ReadAsync  --  USBD_ReadCompleteCb  --  cobs_decode_crc

   main  --  usb_serial_event_queue_process  --  


数据流：usb  -->  usb_serial_rx_raw_buffer  --> usb_serial_rx_cobs_buffe   -->  usb_serial_rx_packet_buffer


----------------------------------

main


    usb_serial_init(usb_serial_packet_received, usb_serial_connect_disconnect);


    while(1)


      usb_serial_event_queue_process();



--------------

参数： usb_serial_packet_received, usb_serial_connect_disconnect
usb_serial_init(  br_callback, ev_callback)
 
    packet_received_callback = usb_serial_packet_received;       //here
    event_callback           = usb_serial_connect_disconnect;

    ...... (忽略)


    _usb_cdc_inst = AddCDC(0, _usb_cdc_rx_raw_buffer, USB_SERIAL_RX_BUFFER_SIZE);        //here
    USBD_CDC_SetOnControlLineState(_usb_cdc_inst, USB_CDC_OnControlLineStateChange);

    USBD_Start();




-----------------------

功能：检测usb打开，读取usb数据
数据流：usb  -->  usb_serial_rx_raw_buffer 
usb_serial_event_queue_process()

    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);   //确定无中断冲突
    
    if(usb_serial_state_port_dtr && !usb_serial_state_port_open)   //DTR打开，亮蓝灯
    
        usb_serial_state_port_dtr = true;
        usb_serial_state_port_open = true;   //DTRV open


        if(usb_serial_timeout_gen != NULL)
            APP_ERROR_CHECK(usb_serial_timeout_gen->set_timeout(usb_serial_buffer_flush_timeout_channel, MS_TO_RTC_TIMEOUT_GEN(500)));

        // Setup first transfer buffer
        _io_context_read.NumBytesToTransfer = USB_SERIAL_RX_BUFFER_SIZE;  // 3 * 1024
        _io_context_read.pData = usb_serial_rx_raw_buffer;

        _io_context_read.pfOnComplete = USBD_ReadCompleteCb;

        //USBD_CDC_ReadAsync(_usb_cdc_inst, &_io_context_read, true);        //here， 读取usb数据
           //USBD_ReadAsync(_aInst[hInst].EPOut, _io_context_read, ShortRead);
              //USB__Read(EPIndex, pContext->pData, pHook->NumBytesToTransfer, 0, Mode);    //数据流：usb --> pContext->pData
              //   USBD_BUFFER_Read(&pEPStat->Dir.RxInfo.Buffer, pData, NumBytesReq);        //数据流： Buffer --> pData  
                       USB_MEMCPY(pData, pBuffer->pData + pBuffer->RdPos, NumBytesAtOnce);    //数据流： pBuffer --> pData  
              //pContext->pfOnComplete(_io_context_read);
                  USBD_ReadCompleteCb(_io_context_read);
    

        if(event_callback != NULL)
        
            //(*event_callback)(USB_SERIAL_EVENT_PORT_OPEN);    
                  usb_serial_connect_disconnect(USB_SERIAL_EVENT_PORT_OPEN);  



-------------------


功能： 取得usb_serial_rx_packet_buffer接收包
数据流：sb_serial_rx_raw_buffer --> usb_serial_rx_cobs_buffer  -->  usb_serial_rx_packet_buffer
参数： _io_context_read
USBD_ReadCompleteCb( *pIOContext)

    for(uint16_t i = 0; i < pIOContext->NumBytesTransferred && usb_serial_rx_cobs_buffer_top<USB_SERIAL_RX_BUFFER_SIZE; i++)
    
        usb_serial_rx_cobs_buffer[usb_serial_rx_cobs_buffer_top++] = usb_serial_rx_raw_buffer[i]; //数据流：sb_serial_rx_raw_buffer -> usb_serial_rx_cobs_buffer 
        if(usb_serial_rx_raw_buffer[i] == 0x00) //End of packet
        
            uint8_t crc;
            size_t packet_size, not_used;

            //Is packet buffer busy
            if(!usb_serial_rx_packet_ready)
            
                //Decode our rx cobs buffer
                cobs_decode_crc(usb_serial_rx_cobs_buffer, usb_serial_rx_cobs_buffer_top - 1,  //数据流：usb_serial_rx_cobs_buffer -> usb_serial_rx_packet_buffer
                                 usb_serial_rx_packet_buffer,USB_SERIAL_RX_BUFFER_SIZE, &crc, &not_used, &packet_size); 

                if(packet_size > 0x00)  //Is this a real packet
                
                    if(crc == 0x00)
                    
                        usb_serial_rx_packet_length = packet_size;
                        usb_serial_rx_packet_ready = true;
                    
                    else
                    
                        usb_serial_send_ack(OMMO_ACK_INVALID_DATA);                    
                
            
            else            
                ;//RX buffer is busy, packet discarded
            

            //Clear our rx cobs buffer
            usb_serial_clear_cobs_rx_buffer();
        
    

    //读取下一包数据
    if(usb_serial_state_port_open) USBD_CDC_ReadAsync(_usb_cdc_inst, &_io_context_read, 1);



------------

数据流：usb_serial_rx_cobs_buffer -> usb_serial_rx_packet_buffer
参数：usb_serial_rx_cobs_buffer, *_cobs_buffer_top - 1, usb_serial_rx_packet_buffer,3*1024, &crc, &not_used, &packet_size
cobs_decode_crc( *ptr, input_length, *dst, dest_buffer_length, *crc, *input_length_used, *dest_length)  //后3个也是输出参数

	const uint8_t *start = dst, *end = ptr + input_length;
	uint8_t code = 0xFF, copy = 0;

        *dest_length = 0;
        *input_length_used = 0;
        *crc = 0;

	for (; ptr < end; copy--)   //待理解

        
            if (*dest_length == dest_buffer_length) // overrun            
                return false;            

            (*input_length_used)++; //Keep track of bytes pulled from input

            if (copy != 0)
            
                uint8_t c = *ptr++;
                
                *dst++ = c;
                (*dest_length)++;

                *crc += c;
            
            else
            
                if (code != 0xFF)
                
                    *dst++ = 0;
                    (*dest_length)++;                

                copy = code = *ptr++;   //待理解

                if (code == 0)
                
                    (*dest_length)--; /* Exclue the 0 terminator from length output */
                    break; /* Source length too long */
                

        /* Exclue the crc from length output */
        if(*dest_length == 0x00)
            return false;
        (*dest_length)--;



--------------

功能：对接收包usb_serial_rx_packet_buffer处理
usb_serial_event_queue_process()

    ASSERT(current_int_priority_get() == APP_IRQ_PRIORITY_THREAD);   //确定无中断冲突

    //cdc uart接收数据处理
    if(usb_serial_rx_packet_ready)
    
        usb_serial_rx_packet_ready = false;

        //Check for block_dev requests
        if(usb_serial_rx_packet_buffer[0] == OMMO_COMMAND_BLOCK_DEV_READ)  //18
        
            if(usb_serial_rx_packet_length != 5)            
                usb_serial_send_ack(OMMO_ACK_INVALID_DATA);
            
            else
            
                uint32_t blk_id;
                memcpy(&blk_id, &usb_serial_rx_packet_buffer[1], 4);

                if(ommo_block_dev_qspi_buffer_read(blk_id, usb_serial_block_dev_buffer + 4, block_dev_ev_handler, NULL) != NRF_SUCCESS) //buf must word aligned                
                    usb_serial_send_ack(OMMO_ACK_INTERNAL_ERROR);

        
        else if(usb_serial_rx_packet_buffer[0] == OMMO_COMMAND_BLOCK_DEV_WRITE)  //19
        
            if(usb_serial_rx_packet_length != (1 + 4 + NRF_BLOCK_DEV_BLOCK_SIZE))            
                usb_serial_send_ack(OMMO_ACK_INVALID_DATA);
            
            else
            
                uint32_t blk_id;
                memcpy(&blk_id, &usb_serial_rx_packet_buffer[1], 4);
                memcpy(usb_serial_block_dev_buffer, &usb_serial_rx_packet_buffer[5], NRF_BLOCK_DEV_BLOCK_SIZE);

                if(ommo_block_dev_qspi_buffer_write(blk_id, usb_serial_block_dev_buffer, block_dev_ev_handler, NULL) != NRF_SUCCESS) ////buffer must be word aligned
                
                    usb_serial_send_ack(OMMO_ACK_INTERNAL_ERROR);

        
        else if(usb_serial_rx_packet_buffer[0] == OMMO_COMMAND_BLOCK_DEV_REQ_GEOMETRY)  //20
        
            if(usb_serial_rx_packet_length != 1)            
                usb_serial_send_ack(OMMO_ACK_INVALID_DATA);
            
            else
            
                const nrf_block_dev_geometry_t *geometry = ommo_block_dev_qspi_buffer_geometry();

                usb_serial_block_dev_buffer[0] = OMMO_COMMAND_BLOCK_DEV_REQ_GEOMETRY;
                memcpy(&usb_serial_block_dev_buffer[1], &geometry->blk_count, 4);
                memcpy(&usb_serial_block_dev_buffer[5], &geometry->blk_size, 4);

                usb_serial_send_command_packet_blocking(usb_serial_block_dev_buffer, 9, false);
            
        
        else if(usb_serial_rx_packet_buffer[0] == OMMO_COMMAND_BLOCK_DEV_SYNCH)  //21
        
            if(usb_serial_rx_packet_length != 1)            
                usb_serial_send_ack(OMMO_ACK_INVALID_DATA);
            
            else
            
                if(ommo_block_dev_qspi_buffer_synch(block_dev_ev_handler, NULL) != NRF_SUCCESS)                
                    usb_serial_send_ack(OMMO_ACK_INTERNAL_ERROR);

        
        else

          if(packet_received_callback != NULL)
        
              //(*packet_received_callback)(usb_serial_rx_packet_buffer, usb_serial_rx_packet_length);
                  usb_serial_packet_received(usb_serial_rx_packet_buffer, usb_serial_rx_packet_length);
        



-----------------------

功能：？
参数：usb_serial_rx_packet_buffer, usb_serial_rx_packet_length
usb_serial_packet_received( data[], length)

    switch(data[0])
    
        case OMMO_COMMAND_USB_DATA_ENABLE:
            if(data_mode != DATA_MODE_DISABLED)
            
                usb_serial_send_ack(OMMO_ACK_INVALID_MODE);
            
            else if(length != 2)
            
                usb_serial_send_ack(OMMO_ACK_INVALID_DATA);
            
            else
            
                //Try to start state machine
                uint32_t rvalue = adc_cartes_start_state_machine();

                if(rvalue == NRF_SUCCESS)
                
                    packet_id = data[1];
                    data_mode = DATA_MODE_USB;
                
                
                //Return success/failure
                usb_serial_send_ack(convert_nrf_error_code_to_ommo_ack_code(rvalue));
                set_leds();
            
            return;
    

    if(response_length == 0) //No response, try protocol agnostic commands
        response_length = process_packet_received(data, length, packet_response_buffer, PACKET_RESPONSE_BUFFER_SIZE);
   
    if(response_length == 0) //No response, must be an unknown command
        response_length = fill_in_ack_packet(packet_response_buffer, OMMO_ACK_UNKNOWN_COMMAND);

    usb_serial_send_command_packet(packet_response_buffer, response_length);















