
参考 ： 10036的dtm示例的debug2_uart.txt



=================================== uarte ===init===============================


（公园）RXD -- 西安旅行社（mcb） --  绿色大巴rx（rx_buffer）  --  上海旅行社（m_rx_fifo）  --  黄色大巴rx（rx_buf） -- byte（游客家里）
（游客家里）byte --上海旅行社（m_tx_fifo） --  黄色大巴tx（tx_buf） --  西安旅行社（mcb） --  绿色大巴tx（tx_buffer） -- TXD（公园）


flow:

     main -- comms_uarte_init -- (irq_handlers[1] = nrfx_uarte_1_irq_handler) -- (p_cb->handler = comms_uarte_handler)


     main -- comms_uarte_init -- nrfx_uarte_init -- apply_config -- nrfx_uarte_rx



数据流：comms_uarte_handler + 常量（len + state）-->  mcb
数据流：nrfx_uarte_1_irq_handler --> irq_handlers[1]
数据流：config --> 寄存器


----------------------------------

main
     
    comms_uarte_init(comms_uarte_synch_uarte, OMMO_COMMS_UARTE_SYNCH_PIN);   //P1.2



------------------

全局变量：comms_uarte_synch_uarte （和comms_uarte相同）
NRFX_UARTE_INSTANCE(1)                              
    .p_reg        = NRF_UARTE1,             
    .drv_inst_idx = NRFX_UARTE1_INST_IDX   //1

参数：comms_uarte_synch_uarte, P1.2
数据流： 常量 -->  m_uart0_drv_config
comms_uarte_init( uarte_instance, rx_pin)

    nrfx_uarte_config_t     m_uart0_drv_config;

    m_uart0_drv_config.pselrxd = rx_pin;                                            //P1.2
    m_uart0_drv_config.pseltxd = NRF_UARTE_PSEL_DISCONNECTED;
    m_uart0_drv_config.pselrts = NRF_UARTE_PSEL_DISCONNECTED;
    m_uart0_drv_config.pselcts = NRF_UARTE_PSEL_DISCONNECTED;
    m_uart0_drv_config.hwfc = NRF_UARTE_HWFC_DISABLED;
    m_uart0_drv_config.parity = NRF_UARTE_PARITY_EXCLUDED;
    m_uart0_drv_config.baudrate = NRF_UARTE_BAUDRATE_1000000;                         //1M波特率
    m_uart0_drv_config.interrupt_priority = NRFX_UARTE_DEFAULT_CONFIG_IRQ_PRIORITY;   //6


    nrfx_uarte_init(&comms_uarte, &m_uart0_drv_config, comms_uarte_handler);


    //Capture our timestamp on uarte rx
    //comms_uarte_local_ts_capture_channel = timestamp_add_capture_event(nrfx_uarte_event_address_get(&comms_uarte, NRF_UARTE_EVENT_ENDRX));   //待理解，先跳过
         AAA = nrf_uarte_event_address_get(NRF_UARTE0, NRF_UARTE_EVENT_ENDRX);
         comms_uarte_local_ts_capture_channel = timestamp_add_capture_event(AAA);


    //把comms_uarte_rx_buffer连接到uarterx的dma，dma一次最大可接收6个byte 开启uarte rx
    nrfx_uarte_rx(&comms_uarte, comms_uarte_rx_buffer, 6);


------------------

参数：comms_uarte, &m_uart0_drv_config, comms_uarte_handler                            
    .p_reg        = NRF_UARTE1,             
    .drv_inst_idx = NRFX_UARTE1_INST_IDX   //1

数据流：comms_uarte_handler + 常量（len + state）-->  mcb
数据流：nrfx_uarte_1_irq_handler --> irq_handlers[1]
数据流：config --> 寄存器
nrfx_uarte_init( * p_instance, * p_config,  event_handler)
 
    p_cb = &m_cb[p_instance->drv_inst_idx]; 

 
    irq_handlers[2] = { nrfx_uarte_0_irq_handler, nrfx_uarte_1_irq_handler };


    //nrfx_prs_acquire(p_instance->p_reg, irq_handlers[1]);        //没有返回成功  （忽略跳过）
       nrfx_prs_acquire(NRF_UARTE1, nrfx_uarte_1_irq_handler );  
     

    apply_config(p_instance, p_config);    //配置串口引脚和波特率

    p_cb->handler   = event_handler;         //comms_uarte_handler
    p_cb->p_context = p_config->p_context;   //0

    if (p_cb->handler)     
        interrupts_enable(p_instance, 6);    //清中断标志，开启中断和优先级，使能中断
    

    nrf_uarte_enable(p_instance->p_reg);  //使能 NRF_UARTE1

    p_cb->rx_buffer_length           = 0;
    p_cb->rx_secondary_buffer_length = 0;
    p_cb->tx_buffer_length           = 0;
    p_cb->state                      = NRFX_DRV_STATE_INITIALIZED;



----------

功能：关联UART的中断入口地址  （忽略跳过，因nrfx_uarte_1_irq_handler自己在.s文件中有定义）
参数： NRF_UARTE1,  nrfx_uarte_1_irq_handler  
nrfx_prs_acquire( * p_base_addr,  irq_handler)  //忽略跳过 （ NRF_UARTE1 不需要 ）

    //prs_box_t * p_box = prs_box_get(p_base_addr);
         p_box =  NULL ；

    if (p_box != NULL)   //no, 不需要执行下面的语句

        if (p_box->acquired)
            busy = true;
        else                                                   
            p_box->handler  = irq_handler;
            p_box->acquired = true;      


---------

功能： 判断NRF_UARTE1  和 NRFX_PRS_BOX_0_ADDR 是否同一个地址
参数：  NRF_UARTE1
prs_box_t * prs_box_get(* p_base_addr)   //忽略跳过 （ NRF_UARTE1 不需要 ）
 
    //#define IS_PRS_BOX(n, p_base_addr)  ((p_base_addr) == NRFX_PRS_BOX_##n##_ADDR)
    #define IS_PRS_BOX(n, NRF_UARTE1 )  ( NRF_UARTE1  == NRFX_PRS_BOX_##n##_ADDR)
 
    //if (IS_PRS_BOX(0, p_base_addr)) 
    if ( NRF_UARTE1  == NRFX_PRS_BOX_0_ADDR )      //no
       return &m_prs_box_0;  

    else   //yes 
        return NULL;              



------------------

参数：NRF_UARTE0.NRF_UARTE_EVENT_ENDRX
timestamp_add_capture_event( trigger_event_addr)
 
nrf_ppi_channel_t        ppi_channel_timestamp_capture;
nrf_timer_cc_channel_t   capture_channel;

    capture_channel = timestamp_get_capture_compare_channel();

    //设置PPI，以便在CC0的样本读取事件中捕获时间戳
    nrfx_ppi_channel_alloc(&ppi_channel_timestamp_capture);
    nrfx_ppi_channel_assign(ppi_channel_timestamp_capture, trigger_event_addr, nrfx_timer_task_address_get(&timer_timestamp, capture_tasks[capture_channel])));
    nrfx_ppi_channel_enable(ppi_channel_timestamp_capture);

    return capture_channel;


--------

nrfx_ppi_channel_alloc(  * p_channel)   //跳过先忽略

    nrf_ppi_channel_t channel;
    uint32_t mask = 0;
    err_code = NRFX_ERROR_NO_MEM;

    mask = NRFX_PPI_PROG_APP_CHANNELS_MASK;

    for (channel = NRF_PPI_CHANNEL0;  mask != 0; mask &= ~nrfx_ppi_channel_to_mask(channel), channel++)
 
        if ((mask & nrfx_ppi_channel_to_mask(channel)) && (!is_allocated_channel(channel)))
        
            channel_allocated_set(channel);
            *p_channel = channel;

 

-------------



//功能：把rx_buffer连接到uarterx的dma，开启uarte rx    //绿色大巴rx 对接dma rx        // 把西安旅行社（mcb）的 绿色大巴rx（rx_buffer）跟RXD（公园）连接起来

全局变量： comms_uarte                             
    .p_reg        = NRF_UARTE1,             
    .drv_inst_idx = NRFX_UARTE1_INST_IDX   //1

参数： comms_uarte, comms_uarte_rx_buffer, 6
数据流： rx_buffer + len(=6) -->  m_cb[0]                        //绿色大巴rx 挂靠 西安旅行社
数据流： rx_buffer  -->  RXD.PTR， 6 -->  RXD.MAXCNT             //绿色大巴rx 对接dma rx

nrfx_uarte_rx(  * p_instance, * p_data,  length)    //注意，这个函数并不只是初始化才调用，在接收数据时会连续调用

    
    (见下面的uarte rx)

 
      


=================================== uarte === rx ===============================


（公园）RXD -- 西安旅行社（mcb） --  绿色大巴rx（rx_buffer）  --  上海旅行社（m_rx_fifo）  --  黄色大巴rx（rx_buf） -- byte（游客家里）

flow：

     main -- comms_uarte_init --  nrfx_uarte_init -- apply_config -- nrfx_uarte_rx

     ses_startup_nrf52833.s -- UARTE1_IRQHandler  --  nrfx_uarte_1_irq_handler  






======-------------------------------------



//功能：把rx_buffer连接到uarterx的dma，开启uarte rx    //绿色大巴rx 对接dma rx        // 把西安旅行社（mcb）的 绿色大巴rx（rx_buffer）跟RXD（公园）连接起来

全局变量： comms_uarte                             
    .p_reg        = NRF_UARTE1,             
    .drv_inst_idx = NRFX_UARTE1_INST_IDX   //1

参数： comms_uarte, comms_uarte_rx_buffer, 6
数据流： rx_buffer + len(=6) -->  m_cb[0]                        //绿色大巴rx 挂靠 西安旅行社
数据流： rx_buffer  -->  RXD.PTR， 6 -->  RXD.MAXCNT             //绿色大巴rx 对接dma rx

nrfx_uarte_rx(  * p_instance, * p_data,  length)    //注意，这个函数并不只是初始化才调用，在接收数据时会连续调用

    p_cb = &m_cb[1];

    bool second_buffer = false;      

    if (p_cb->handler)    //comms_uarte_handler
        nrf_uarte_int_disable( NRF_UARTE1, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);  //关闭2个中断

    
    if ( p_cb->rx_buffer_length != 0 )         //第一次是no, 跳过     
        if ( p_cb->rx_secondary_buffer_length != 0 )            
            if (p_cb->handler)        //  yes， uart_error_handle             
                nrf_uarte_int_enable(p_instance->p_reg, NRF_UARTE_INT_ERROR_MASK |  NRF_UARTE_INT_ENDRX_MASK);
            return err_code;         
        second_buffer = true;     

    if (!second_buffer)     //第一次是yes 
        p_cb->rx_buffer_length = length;              //6
        p_cb->p_rx_buffer      = p_data;              //rx_buffer 
        p_cb->rx_secondary_buffer_length = 0;
 
    else   //no
        p_cb->p_rx_secondary_buffer = p_data;            //rx_buffer 
        p_cb->rx_secondary_buffer_length = length;       //6

    nrf_uarte_event_clear(p_instance->p_reg, NRF_UARTE_EVENT_ENDRX);   //或清除中断标志
    nrf_uarte_event_clear(p_instance->p_reg, NRF_UARTE_EVENT_RXTO);     //或清除中断标志


    //nrf_uarte_rx_buffer_set(p_instance->p_reg, p_data, length);
        NRF_UARTE0->RXD.PTR    = rx_buffer;                                   //绿色大巴rx 对接dma rx
        NRF_UARTE0->RXD.MAXCNT =6;                                            //或dma中最大接收数量


    if (!second_buffer)    //第一次是yes
   
        //nrf_uarte_task_trigger(p_instance->p_reg, NRF_UARTE_TASK_STARTRX);
           TASK_STARTRX = 1;    //开启uarte 接收

    else    
        nrf_uarte_shorts_enable(p_instance->p_reg, NRF_UARTE_SHORT_ENDRX_STARTRX);
            SHORTS |= (1<<5);   //使能shortcut ， event ENDRX and task STARTRX之间的shortcut      //待理解  （或跟循环接收有关）


    if (m_cb[0].handler == NULL)   //no   （comms_uarte_handler）    
            。。。 
  
    else        //yes

        //nrf_uarte_int_enable(p_instance->p_reg, NRF_UARTE_INT_ERROR_MASK |   NRF_UARTE_INT_ENDRX_MASK);
              INTENSET = ERROR | ENDRX；   //使能这2个中断


 


======-------------------------------------


uarte_irq_handler(NRF_UARTE_Type *        p_uarte,
                              uarte_control_block_t * p_cb)
{
    if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ERROR))
    {
        nrfx_uarte_event_t event;

        nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ERROR);

        event.type                   = NRFX_UARTE_EVT_ERROR;
        event.data.error.error_mask  = nrf_uarte_errorsrc_get_and_clear(p_uarte);
        event.data.error.rxtx.bytes  = nrf_uarte_rx_amount_get(p_uarte);
        event.data.error.rxtx.p_data = p_cb->p_rx_buffer;

        // Abort transfer.
        p_cb->rx_buffer_length = 0;
        p_cb->rx_secondary_buffer_length = 0;

        p_cb->handler(&event, p_cb->p_context);
    }
    else if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ENDRX))
    {
        nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ENDRX);
        size_t amount = nrf_uarte_rx_amount_get(p_uarte);
        // If the transfer was stopped before completion, amount of transfered bytes
        // will not be equal to the buffer length. Interrupted transfer is ignored.
        if (amount == p_cb->rx_buffer_length)
        {
            if (p_cb->rx_secondary_buffer_length != 0)
            {
                uint8_t * p_data = p_cb->p_rx_buffer;
                nrf_uarte_shorts_disable(p_uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
                p_cb->rx_buffer_length = p_cb->rx_secondary_buffer_length;
                p_cb->p_rx_buffer = p_cb->p_rx_secondary_buffer;
                p_cb->rx_secondary_buffer_length = 0;
                rx_done_event(p_cb, amount, p_data);
            }
            else
            {
                p_cb->rx_buffer_length = 0;
                rx_done_event(p_cb, amount, p_cb->p_rx_buffer);
            }
        }
    }

    if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_RXTO))
    {
        nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_RXTO);

        if (p_cb->rx_buffer_length != 0)
        {
            p_cb->rx_buffer_length = 0;
            // In case of using double-buffered reception both variables storing buffer length
            // have to be cleared to prevent incorrect behaviour of the driver.
            p_cb->rx_secondary_buffer_length = 0;
            rx_done_event(p_cb, nrf_uarte_rx_amount_get(p_uarte), p_cb->p_rx_buffer);
        }
    }

   

-----------

 rx_done_event(  * p_cb,   bytes,   p_data)
 
    nrfx_uarte_event_t event;

    event.type             = NRFX_UARTE_EVT_RX_DONE;
    event.data.rxtx.bytes  = bytes;
    event.data.rxtx.p_data = p_data;

    //p_cb->handler(&event, p_cb->p_context);
        comms_uarte_handler( &event, p_cb->p_context);

 

--------------------


参数：event, p_cb->p_context
comms_uarte_handler(  *p_event,  *p_context) 

    if(p_event->type == NRFX_UARTE_EVT_RX_DONE)
     
        index = (comms_uarte_in_synch?0:1);
        if(comms_uarte_rx_buffer[index+5] == 0x00)
        
            comms_uarte_in_synch = true;

            //Grab basestation timestmap @ sample_time and roll forward by TIMESTAMP_SYNCH_BS_PERIOD to the correct time for our sample event
            cobs_decode(comms_uarte_rx_buffer+index, 5, (uint8_t*)&basestation_ts);

            //Process timestamp
            timestamp_synch_recieved(basestation_ts, timestamp_read_capture(comms_uarte_local_ts_capture_channel), TIMESTAMP_SYNCH_SOURCE_UART);

            //Setup next RX
            OMMO_APP_ERROR_CHECK(nrfx_uarte_rx(&comms_uarte, comms_uarte_rx_buffer, 6), STRING("UARTE communication error"), 0);
         
        else
         
            nrfx_uarte_rx(&comms_uarte, comms_uarte_rx_buffer, 7);
            comms_uarte_in_synch = false;
        

     
    else if(p_event->type == NRFX_UARTE_EVT_ERROR)
     
        comms_uarte_error_count++;

        nrfx_uarte_rx(&comms_uarte, comms_uarte_rx_buffer, 6);
 




==============================================参考1===============keep===========================================================


    if(rx_pin != NRF_UARTE_PSEL_DISCONNECTED)
        nrf_gpio_cfg_input(rx_pin, NRF_GPIO_PIN_PULLUP);    //Prevents random rx events


---------------------






==============================================参考==========================================================================


  
      

**------------


timestamp_is_synch_lost()
 

#ifndef RUN_WITHOUT_SYNC
    return timestamp_synch_lost;
#else
    return false;                  //false  -- 指不需要同步信号 (没有失去同步信号，相当于虚空增加了一个同步信号)
#endif
 
 
 
 ----------


task_loop_timer_function()

    task_loop_timer_execute = false;

    if(timestamp_is_synch_lost())
    
        basestation_lost_count++;
        if(basestation_lost_count > BASESTATION_LOST_TIMEOUT && data_mode == DATA_MODE_WIRELESS)
        
            disable_data_mode(true);
            set_leds();

    else
    
        basestation_lost_count = 0;
    

    ......



---------

sample_set_ready(uint8_t *data, uint16_t data_size, uint32_t timestamp, uint32_t timestamp_offset)

    //Wait until we are enabled and have synch
    if(data_mode == DATA_MODE_DISABLED || timestamp_is_synch_lost())
        return;

    if(data_mode == DATA_MODE_USB)
    
        //Calculate decoded packet size
        size_t packet_size = 1 + 4 + data_size;
 

        //Do COBS encoding, add packet delimiter(s) (0x00), and transmit via USB
        uint32_t code = usb_serial_write_data_packet_vargs(packet_size,
            1, &packet_id,
            4, &timestamp,
 
            data_size, data,
            0);

        if(code == NRF_ERROR_BUSY)
            skipped_tx_count++;
        else
            OMMO_APP_ERROR_CHECK(code, STRING("USB data transfer error"), 0);
    

    //Update count
    tx_count++;


----------


void task_loop_timer_function()
{
    //Clear flag
    task_loop_timer_execute = false;

    //Watch for BS lost
    if(timestamp_is_synch_lost())
    {
        basestation_lost_count++;
        if(basestation_lost_count > BASESTATION_LOST_TIMEOUT && data_mode == DATA_MODE_WIRELESS)
        {
            disable_data_mode(true);
            set_leds();
        }
    }
    else
    {
        basestation_lost_count = 0;
    }

    #ifdef OMMO_BUTTON_PIN
    //Watch for button to be released
    if(button_down && (nrfx_gpiote_in_is_set(OMMO_BUTTON_PIN)^OMMO_BUTTON_ACTIVE_STATE))
    {
        nrfx_timer_disable(&button_down_timer);
        nrfx_timer_clear(&button_down_timer);
        button_down = false;
    }
    #endif
}


-----------

set_leds()
 

    if(!usb_serial_state_port_open)
     
        main_led.set_basic(LED_MODE_USB_CLOSED, LED_COLOR_USB_CLOSED);     //白灯呼吸。usb串口关闭
     
    else if(usb_serial_state_port_open && data_mode == DATA_MODE_DISABLED) 
     
        if(led_state != 0x03)
         
            led_state = 0x03;
            main_led.set_basic(LED_MODE_USB_OPEN, LED_COLOR_USB_OPEN);    //蓝灯呼吸。usb串口打开，未进入DATA_MODE
         
    
    else if(timestamp_is_synch_lost())
     
        if(led_state != 0x04)
         
            led_state = 0x04;
            main_led.set_basic(LED_MODE_EN_SYNCH_LOST, LED_COLOR_EN_SYNCH_LOST);  //蓝灯快闪， 无同步信号
         
     
    else if(!timestamp_is_synch_wired())
     
        if(led_state != 0x06)
         
            led_state = 0x06;
 
            main_led.set_basic(LED_MODE_EN_SYNCH_WIRELESS, LED_COLOR_EN_SYNCH_WIRELESS); //绿灯呼吸，或无线同步信号
     
    else
    
        if(led_state != 0x07)
         
            led_state = 0x07;
            main_led.set_basic(LED_MODE_EN_SYNCH_WIRED, LED_COLOR_EN_SYNCH_WIRED);   // 绿灯常亮，有同步信号，正常通讯
         
     
---------

timestamp_is_synch_wired()

    return timestamp_synch_esb_ignore_count > 0;

























































